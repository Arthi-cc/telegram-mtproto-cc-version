{"version":3,"sources":["../../src/task/decrypt.js"],"names":["decrypt","result","data","dc","uid","input","fold","mapRej","ERR","noKeys","map","keys","session","get","chain","decryptor","validateDecrypt","decrypted","thread","authID","auth","rest","responseBuffer","authKeyID","authKey","thisSessionID","prevSessionID","getMsgById","response","invalidResponse","NoSessionKeys","Error","InvalidResponse"],"mappings":";;;;;QAYgBA,O,GAAAA,O;;AAVhB;;AAEA;;AAGA;;AACA;;;;AACA;;AACA;;;;;;;;AAEO,SAASA,OAAT,OAAoE;AAAA,MAAnD,EAAEC,QAAQ,EAAEC,IAAF,EAAV,EAAoBC,EAApB,EAAwBC,GAAxB,EAAmD;AAAA,MAAnBC,KAAmB;;AACzE,SAAO,sBAAUD,GAAV,EAAeD,EAAf,EACJG,IADI,+BAEJC,MAFI,CAEGC,IAAIC,MAFP,EAGJC,GAHI,CAGAC,0BACAN,KADA,EAEAM,IAFA;AAGHT,QAHG;AAIHC,MAJG;AAKHC,OALG;AAMHQ,aAAS,yBAAOA,OAAP,CAAeC,GAAf,CAAmBT,GAAnB,EAAwBD,EAAxB;AANN,IAHA,EAWJW,KAXI,CAWEC,SAXF,EAYJD,KAZI,CAYEE,eAZF,EAaJN,GAbI,CAaAO,+BAAmBZ,KAAnB,IAA0BF,EAA1B,EAA8BC,GAA9B,IAAsCa,SAAtC,CAbA,CAAP;AAcD;;AAED,IAAMF,YAAY;AAAA,MAAC,EAAEG,MAAF,EAAUhB,IAAV,EAAgBE,GAAhB,EAAqBD,EAArB,EAAyBgB,MAAzB,EAAiCC,IAAjC,EAAuCR,OAAvC,EAAD;AAAA,MAAoDS,IAApD;;AAAA,SAChB,uCAAgB;AACdC,oBAAgBpB,IADF;AAEdE,OAFc;AAGdD,MAHc;AAIdoB,eAAgBJ,MAJF;AAKdK,aAAgBJ,IALF;AAMdK,mBAAgBb,OANF;AAOdc,mBAAgBR,OAAOQ,aAPT;AAQdC,gBAAgBT,OAAOS;AART,GAAhB,EASGjB,GATH,CASOT,4BAAgBA,MAAhB,IAAwBiB,MAAxB,EAAgCd,GAAhC,EAAqCD,EAArC,EAAyCgB,MAAzC,EAAiDC,IAAjD,EAAuDR,OAAvD,IAAmES,IAAnE,CATP,CADgB;AAAA,CAAlB;;AAYA,SAASL,eAAT,CAAyBC,SAAzB,EAAoC;AAClC,MAAM,EAAEW,QAAF,KAAeX,SAArB;AACA,MAAI,CAAC,2BAAYW,QAAZ,CAAL,EAA4B;AAC1B,WAAO,qBAAOpB,IAAIqB,eAAJ,EAAP,CAAP;AACD;AACD,SAAO,iBAAGZ,SAAH,CAAP;AACD;;AAGD,MAAMa,aAAN,SAA4BC,KAA5B,CAAkC;AAClC,MAAMC,eAAN,SAA8BD,KAA9B,CAAoC;AACpC,IAAMvB,MAAM;AACVC,UAAiB,MAAM,IAAIqB,aAAJ,CAAkB,iBAAlB,CADb;AAEVD,mBAAiB,MAAM,IAAIG,eAAJ,CAAoB,4BAApB;AAFb,CAAZ","file":"decrypt.js","sourcesContent":["//@flow\n\nimport { encaseP, of, reject } from 'fluture'\n\nimport {\n  type RawInput,\n} from './index.h'\nimport { isApiObject } from './fixtures'\nimport parser from '../service/chain'\nimport { queryKeys } from '../state/query'\nimport Config from 'ConfigProvider'\n\nexport function decrypt({ result: { data }, dc, uid, ...input }: RawInput) {\n  return queryKeys(uid, dc)\n    .fold(reject, of)\n    .mapRej(ERR.noKeys)\n    .map(keys => ({\n      ...input,\n      ...keys,\n      data,\n      dc,\n      uid,\n      session: Config.session.get(uid, dc),\n    }))\n    .chain(decryptor)\n    .chain(validateDecrypt)\n    .map(decrypted => ({ ...input, dc, uid, ...decrypted }))\n}\n\nconst decryptor = ({ thread, data, uid, dc, authID, auth, session, ...rest }) =>\n  encaseP(parser, {\n    responseBuffer: data,\n    uid,\n    dc,\n    authKeyID     : authID,\n    authKey       : auth,\n    thisSessionID : session,\n    prevSessionID : thread.prevSessionID,\n    getMsgById    : thread.getMsgById,\n  }).map(result => ({ ...result, thread, uid, dc, authID, auth, session, ...rest }))\n\nfunction validateDecrypt(decrypted) {\n  const { response } = decrypted\n  if (!isApiObject(response)) {\n    return reject(ERR.invalidResponse())\n  }\n  return of(decrypted)\n}\n\n\nclass NoSessionKeys extends Error {  }\nclass InvalidResponse extends Error {  }\nconst ERR = {\n  noKeys         : () => new NoSessionKeys('No session keys'),\n  invalidResponse: () => new InvalidResponse('Invalid decrypted response'),\n}\n"]}