{"version":3,"sources":["../../../src/service/chain/encrypted-message.js"],"names":["apiMessage","mtMessage","ctx","serverSalt","sessionID","message","msg_id","seq_no","body","length","apiBytes","getBuffer","sha1HashPlain","bytes","sha1Hash","msgKeyFromHash","hash","Uint8Array","subarray","aesFromSha1","authKey","msgKey","encryptAES","aesKey","aesIv","aesEncrypt","makeMsgKey","map","makeAesKeys","makeEncryptedBytes","pair","chain","aes","result","encryptApiBytes","authKeyID","encryptedBytes","mtBytes","getArray"],"mappings":";;;;;;QA8BgBA,U,GAAAA,U;QA6DAC,S,GAAAA,S;;AA1FhB;;AAEA;;;;AACA;;;;AACA;;AAEA;;AACA;;AACA;;;;AACA;;AAEA;;;AAkBO,SAASD,UAAT,CAAoB,EAAEE,GAAF,EAAOC,UAAP,EAAmBC,SAAnB,EAA8BC,OAA9B,EAApB,EAA8E;AACnF,6BAAcH,GAAd,EAAmBC,UAAnB,EAA+B,EAA/B;AACA,6BAAcD,GAAd,EAAmBE,SAAnB,EAA8B,EAA9B;AACA,yBAAUF,GAAV,EAAeG,QAAQC,MAAvB,EAA+B,YAA/B;AACA,wBAASJ,GAAT,EAAcG,QAAQE,MAAtB,EAA8B,QAA9B;;AAEA,wBAASL,GAAT,EAAcG,QAAQG,IAAR,CAAaC,MAA3B,EAAmC,qBAAnC;AACA,6BAAcP,GAAd,EAAmBG,QAAQG,IAA3B,EAAiC,KAAjC;;AAEA,MAAME,WAAWR,IAAIS,SAAJ,EAAjB;;AAEA,SAAOD,QAAP;AACD;;AAKD,IAAME,gBAAgBC,SAAS,iBAAaC,QAAb,CAAsBD,KAAtB,CAA/B;AACA,IAAME,iBAAiBC,QAAQ,IAAIC,UAAJ,CAAeD,IAAf,EAAqBE,QAArB,CAA8B,CAA9B,EAAiC,EAAjC,CAA/B;AACA,IAAMC,cAAc,CAACC,OAAD,EAAUC,MAAV,KAAqB,sBAAYD,OAAZ,EAAqBC,MAArB,EAA6B,IAA7B,CAAzC;AACA,IAAMC,aAAa,CAACT,KAAD,EAAQ,CAACU,MAAD,EAASC,KAAT,CAAR,KAA4B,iBAC5CC,UAD4C,CACjCZ,KADiC,EAC1BU,MAD0B,EAClBC,KADkB,CAA/C;;AAeA,IAAME,aACJb,SAAS,sBAAQD,aAAR,EAAuBC,KAAvB,EACNc,GADM,CACFZ,cADE,CADX;;AAIA,IAAMa,cACJ,CAACR,OAAD,EAAUC,MAAV,KACE,uBAASF,WAAT,EAAsBC,OAAtB,EAA+BC,MAA/B,CAFJ;;AAKA,IAAMQ,qBACJ,CAAChB,KAAD,EAAQiB,IAAR,KAAiB,uBAASR,UAAT,EAAqBT,KAArB,EAA4BiB,IAA5B,CADnB;;AAGA,IAAML,aAAa,CAACZ,KAAD,EAAQO,OAAR,EAAiBC,MAAjB,KACjBO,YAAYR,OAAZ,EAAqBC,MAArB,EACGU,KADH,CACSC,OAAOH,mBAAmBhB,KAAnB,EAA0BmB,GAA1B,CADhB,EAEGL,GAFH,CAEOM,WAAW,EAAEpB,OAAOoB,MAAT,EAAiBZ,MAAjB,EAAX,CAFP,CADF;;AAKO,IAAMa,4CAAkB,CAC7BrB,KAD6B,EAE7BO,OAF6B,KAK7BM,WAAWb,KAAX,EACGkB,KADH,CACSV,UAAUI,WAAWZ,KAAX,EAAkB,8BAAoBO,OAApB,CAAlB,EAAgDC,MAAhD,CADnB,CALK;;AASA,SAASpB,SAAT,CAAmB,EAAEC,GAAF,EAAOiC,SAAP,EAAkBd,MAAlB,EAA0Be,cAA1B,EAAnB,EAA+E;AACpF,6BAAclC,GAAd,EAAmBiC,SAAnB,EAA8B,EAA9B;AACA,6BAAcjC,GAAd,EAAmBmB,MAAnB,EAA2B,GAA3B;AACA,6BAAcnB,GAAd,EAAmBkC,cAAnB,EAAmC,KAAnC;;AAEA,MAAMC,UAAUnC,IAAIoC,QAAJ,EAAhB;;AAEA,SAAOD,OAAP;AACD","file":"encrypted-message.js","sourcesContent":["//@flow\nimport { encaseP, encaseP2, Fluture } from 'fluture'\n\nimport CryptoWorker from '../../crypto'\nimport getMsgKeyIv from './msg-key'\nimport { writeInt, writeIntBytes, writeLong } from '../../tl/writer'\n\nimport { NetMessage } from '../networker/net-message'\nimport { TypeWriter } from '../../tl/type-buffer'\nimport { convertToUint8Array } from '../../bin'\n// import Logger from 'mtproto-logger'\n\n// const log = Logger`encrypted message`\n\n\ntype ApiMessageProps = {\n  ctx: TypeWriter,\n  serverSalt: number[],\n  sessionID: number[],\n  message: NetMessage\n}\n\ntype MtMessageProps = {\n  ctx: TypeWriter,\n  authKeyID: number[],\n  msgKey: Uint8Array,\n  encryptedBytes: ArrayBuffer\n}\n\n\nexport function apiMessage({ ctx, serverSalt, sessionID, message }: ApiMessageProps) {\n  writeIntBytes(ctx, serverSalt, 64)\n  writeIntBytes(ctx, sessionID, 64)\n  writeLong(ctx, message.msg_id, 'message_id')\n  writeInt(ctx, message.seq_no, 'seq_no')\n\n  writeInt(ctx, message.body.length, 'message_data_length')\n  writeIntBytes(ctx, message.body, false)\n\n  const apiBytes = ctx.getBuffer()\n\n  return apiBytes\n}\n\nopaque type SHA1Error: Error = Error\nopaque type AESError: Error = Error\nopaque type EncryptError: Error = Error\nconst sha1HashPlain = bytes => CryptoWorker.sha1Hash(bytes)\nconst msgKeyFromHash = hash => new Uint8Array(hash).subarray(4, 20)\nconst aesFromSha1 = (authKey, msgKey) => getMsgKeyIv(authKey, msgKey, true)\nconst encryptAES = (bytes, [aesKey, aesIv]) => CryptoWorker\n  .aesEncrypt(bytes, aesKey, aesIv)\n\ntype MakeMsgKey = (bytes: ArrayBuffer) => Fluture<Uint8Array, SHA1Error>\n\ntype MakeAesKeys = (\n  authKey: Uint8Array,\n  msgKey: Uint8Array\n) => Fluture<[Uint8Array, Uint8Array], AESError>\n\ntype MakeEncryptedBytes = (\n  bytes: ArrayBuffer,\n  aes: [Uint8Array, Uint8Array]\n) => Fluture<ArrayBuffer, EncryptError>\n\nconst makeMsgKey: MakeMsgKey =\n  bytes => encaseP(sha1HashPlain, bytes)\n    .map(msgKeyFromHash)\n\nconst makeAesKeys: MakeAesKeys =\n  (authKey, msgKey) =>\n    encaseP2(aesFromSha1, authKey, msgKey)\n\n\nconst makeEncryptedBytes: MakeEncryptedBytes =\n  (bytes, pair) => encaseP2(encryptAES, bytes, pair)\n\nconst aesEncrypt = (bytes, authKey, msgKey) =>\n  makeAesKeys(authKey, msgKey)\n    .chain(aes => makeEncryptedBytes(bytes, aes))\n    .map(result => ({ bytes: result, msgKey }))\n\nexport const encryptApiBytes = (\n  bytes: ArrayBuffer,\n  authKey: number[]\n) =>\n\n  makeMsgKey(bytes)\n    .chain(msgKey => aesEncrypt(bytes, convertToUint8Array(authKey), msgKey))\n\n\nexport function mtMessage({ ctx, authKeyID, msgKey, encryptedBytes }: MtMessageProps) {\n  writeIntBytes(ctx, authKeyID, 64)\n  writeIntBytes(ctx, msgKey, 128)\n  writeIntBytes(ctx, encryptedBytes, false)\n\n  const mtBytes = ctx.getArray()\n\n  return mtBytes\n}\n"]}