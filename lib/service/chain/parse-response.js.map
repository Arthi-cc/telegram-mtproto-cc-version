{"version":3,"sources":["../../../src/service/chain/parse-response.js"],"names":["authKey","msgKey","encryptedData","aesKey","aesIv","dataWithPadding","aesDecrypt","getDataWithPad","hashData","reader","dataHash","sha1Hash","slice","console","warn","Error","response","fetchObject","parsedResponse","readResponse","readHash","authKeyStored","authKeyID","fetchIntBytes","toString","fetchRawBytes","byteLength","getOffset","currentSession","prevSession","uid","sessionID","messageID","typeBuffer","isInvalidSession","seqNo","fetchInt","offset","totalLength","messageBodyLength","messageBody","buffer","paddingLength","subarray"],"mappings":";;;;;;;;+BAqDO,WAA8B,EAAEA,OAAF,EAAWC,MAAX,EAAmBC,aAAnB,EAA9B,EAAkF;AACvF,QAAM,CAACC,MAAD,EAASC,KAAT,IAAkB,MAAM,sBAAYJ,OAAZ,EAAqBC,MAArB,EAA6B,KAA7B,CAA9B;AACA,QAAMI,kBAAkB,MAAM,iBAAaC,UAAb,CAAwBJ,aAAxB,EAAuCC,MAAvC,EAA+CC,KAA/C,CAA9B;AACA,WAAOC,eAAP;AACD,G;;kBAJqBE,c;;;;;;gCAmDf,WAA8B,EAAEC,QAAF,EAAYP,MAAZ,EAAoBQ,MAApB,EAA9B,EAA4E;AACjF,QAAMC,WAAW,MAAM,iBAAaC,QAAb,CAAsBH,QAAtB,CAAvB;;AAEA,QAAI,CAAC,mBAASP,MAAT,EAAiB,+BAAqBS,QAArB,EAA+BE,KAA/B,CAAqC,CAAC,EAAtC,CAAjB,CAAL,EAAkE;AAChEC,cAAQC,IAAR,CAAab,MAAb,EAAqB,+BAAqBS,QAArB,CAArB;AACA,YAAM,IAAIK,KAAJ,CAAU,6BAAV,CAAN;AACD;AACD,QAAMC,WAAWP,OAAOQ,WAAP,CAAmB,EAAnB,EAAuB,OAAvB,CAAjB;;AAEA,WAAOD,QAAP;AACD,G;;kBAVqBE,c;;;;;QArENC,Y,GAAAA,Y;QAwBAC,Q,GAAAA,Q;;AAzDhB;;AACA;;AACA;;;;AACA;;;;AACA;;;;;;AA6BO,SAASD,YAAT,CAAsB,EAAEH,QAAF,EAAYP,MAAZ,EAAoBY,aAApB,EAAtB,EAAyE;AAC9E,MAAMC,YAAYb,OAAOc,aAAP,CAAqB,EAArB,EAAyB,aAAzB,CAAlB;AACA,MAAI,CAAC,mBAASD,SAAT,EAAoBD,aAApB,CAAL,EAAyC;AAAE;AACzC,UAAM,IAAIN,KAAJ,CACH,oCAAmCO,UAAUE,QAAV,EAAqB,IAAG,qBAAWF,SAAX,CAAsB,oBAAmBD,cAAcG,QAAd,EAAyB,IAAG,qBAAWH,aAAX,CAA0B,EADvJ,CAAN;AAGD;AACD,MAAMpB,SAASQ,OAAOc,aAAP,CAAqB,GAArB,EAA0B,SAA1B,CAAf;AACA,MAAMrB,gBAAgBO,OAAOgB,aAAP,CACpBT,SAASU,UAAT,GAAsBjB,OAAOkB,SAAP,EADF,EAEpB,gBAFoB,CAAtB;AAGA,SAAO;AACL1B,UADK;AAELC;AAFK,GAAP;AAID;;AASM,SAASkB,QAAT,CAAkB,EAAEX,MAAF,EAAUmB,cAAV,EAA0BC,WAA1B,EAAuCxB,eAAvC,EAAwDyB,GAAxD,EAAlB,EAA2F;AAChGrB,SAAOc,aAAP,CAAqB,EAArB,EAAyB,MAAzB;AACA,MAAMQ,YAAYtB,OAAOc,aAAP,CAAqB,EAArB,EAAyB,YAAzB,CAAlB;AACA,MAAMS,YAAY,sBAASvB,OAAOwB,UAAhB,EAA4B,YAA5B,CAAlB;;AAEA,MAAMC,mBAAmB,CAAC,mBAASH,SAAT,EAAoBH,cAApB,CAAD,KAAyC,CAACC;AACjE;AADgE,KAE7D,CAAC,mBAASE,SAAT,EAAoBF,WAApB,CAFmB,CAAzB;AAGA,MAAIK,gBAAJ,EAAsB;AACpBrB,YAAQC,IAAR,CAAa,wBAAb,EAAuCiB,SAAvC,EAAkDH,cAAlD,EAAkEC,WAAlE;AACA;AACD;;AAED,MAAMM,QAAQ1B,OAAO2B,QAAP,CAAgB,QAAhB,CAAd;;AAEA,MAAIC,SAAS5B,OAAOkB,SAAP,EAAb;AACA,MAAMW,cAAcjC,gBAAgBqB,UAApC;;AAEA,MAAMa,oBAAoB9B,OAAO2B,QAAP,CAAgB,sBAAhB,CAA1B;AACA,MAAIG,oBAAoB,CAApB,IACCA,oBAAoBD,cAAcD,MADvC,EAC+C;AAC7C,UAAM,IAAItB,KAAJ,CAAW,6BAA8BwB,iBAAkB,EAA3D,CAAN;AACD;AACD,MAAMC,cAAc/B,OAAOgB,aAAP,CAAqBc,iBAArB,EAAwC,cAAxC,CAApB;;AAEA,MAAME,SAAS,6BAAmBD,WAAnB,CAAf;;AAEAH,WAAS5B,OAAOkB,SAAP,EAAT;AACA,MAAMe,gBAAgBJ,cAAcD,MAApC;AACA,MAAIK,gBAAgB,CAAhB,IAAqBA,gBAAgB,EAAzC,EACE,MAAM,IAAI3B,KAAJ,CAAW,gCAA+B2B,aAAc,EAAxD,CAAN;AACF,MAAMlC,WACJ,8BAAoBH,eAApB,EACGsC,QADH,CACY,CADZ,EACeN,MADf,CADF;;AAIA,SAAO;AACL7B,YADK;AAEL2B,SAFK;AAGLH,aAHK;AAILD,aAJK;AAKLU;AALK,GAAP;AAOD","file":"parse-response.js","sourcesContent":["//@flow\n\nimport { Deserialization } from '../../tl'\nimport { bytesCmp, bytesToHex, convertToUint8Array, bytesToArrayBuffer, bytesFromArrayBuffer } from '../../bin'\nimport CryptoWorker from '../../crypto'\nimport getMsgKeyIv from './msg-key'\nimport { readLong } from '../../tl/reader'\n\ntype ReadResponse = {\n  response: ArrayBuffer | Buffer,\n  reader: Deserialization,\n  authKeyStored: number[]\n}\n\ntype GetDataWithPad = {\n  authKey: Uint8Array,\n  msgKey: Uint8Array,\n  encryptedData: Uint8Array\n}\n\ntype ReadHash = {\n  reader: Deserialization,\n  currentSession: number[],\n  prevSession: number[],\n  dataWithPadding: ArrayBuffer,\n  uid: string,\n}\n\ntype ParsedResponse = {\n  hashData: Uint8Array,\n  msgKey: Uint8Array,\n  reader: Deserialization,\n}\n\n\nexport function readResponse({ response, reader, authKeyStored }: ReadResponse) {\n  const authKeyID = reader.fetchIntBytes(64, 'auth_key_id')\n  if (!bytesCmp(authKeyID, authKeyStored)) { //TODO Remove auth keys from logs\n    throw new Error(\n      `[MT] Invalid server auth_key_id: ${authKeyID.toString()} ${bytesToHex(authKeyID)}, authKeyStored: ${authKeyStored.toString()} ${bytesToHex(authKeyStored)}`\n    )\n  }\n  const msgKey = reader.fetchIntBytes(128, 'msg_key')\n  const encryptedData = reader.fetchRawBytes(\n    response.byteLength - reader.getOffset(),\n    'encrypted_data')\n  return {\n    msgKey,\n    encryptedData\n  }\n}\n\n\nexport async function getDataWithPad({ authKey, msgKey, encryptedData }: GetDataWithPad) {\n  const [aesKey, aesIv] = await getMsgKeyIv(authKey, msgKey, false)\n  const dataWithPadding = await CryptoWorker.aesDecrypt(encryptedData, aesKey, aesIv)\n  return dataWithPadding\n}\n\nexport function readHash({ reader, currentSession, prevSession, dataWithPadding, uid }: ReadHash) {\n  reader.fetchIntBytes(64, 'salt')\n  const sessionID = reader.fetchIntBytes(64, 'session_id')\n  const messageID = readLong(reader.typeBuffer, 'message_id')\n\n  const isInvalidSession = !bytesCmp(sessionID, currentSession) && (!prevSession\n    //eslint-disable-next-line\n    || !bytesCmp(sessionID, prevSession));\n  if (isInvalidSession) {\n    console.warn('Invalid server session', sessionID, currentSession, prevSession)\n    // throw new Error(`[MT] Invalid server session_id: ${ bytesToHex(sessionID) } ${sessionID.toString()}  ${bytesToHex(currentSession)} ${currentSession.toString()}`)\n  }\n\n  const seqNo = reader.fetchInt('seq_no')\n\n  let offset = reader.getOffset()\n  const totalLength = dataWithPadding.byteLength\n\n  const messageBodyLength = reader.fetchInt('message_data[length]')\n  if (messageBodyLength % 4\n    || messageBodyLength > totalLength - offset) {\n    throw new Error(`[MT] Invalid body length: ${  messageBodyLength}`)\n  }\n  const messageBody = reader.fetchRawBytes(messageBodyLength, 'message_data')\n\n  const buffer = bytesToArrayBuffer(messageBody)\n\n  offset = reader.getOffset()\n  const paddingLength = totalLength - offset\n  if (paddingLength < 0 || paddingLength > 15)\n    throw new Error(`[MT] Invalid padding length: ${paddingLength}`)\n  const hashData =\n    convertToUint8Array(dataWithPadding)\n      .subarray(0, offset)\n\n  return {\n    hashData,\n    seqNo,\n    messageID,\n    sessionID,\n    buffer\n  }\n}\n\n\nexport async function parsedResponse({ hashData, msgKey, reader }: ParsedResponse) {\n  const dataHash = await CryptoWorker.sha1Hash(hashData)\n\n  if (!bytesCmp(msgKey, bytesFromArrayBuffer(dataHash).slice(-16))) {\n    console.warn(msgKey, bytesFromArrayBuffer(dataHash))\n    throw new Error('[MT] server msgKey mismatch')\n  }\n  const response = reader.fetchObject('', 'INPUT')\n\n  return response\n}\n"]}