{"version":3,"sources":["../../../src/state/epic/index.js"],"names":["filterActions","list","action","type","Blackhole","state","homeDc","status","toJSON","TASK","NEW","payload","netReq","uid","request","values","dc","homeStatus","keys","map","auth","authID","salt","authKey","authKeyID","serverSalt","fold","x","AUTH","RESOLVE","promise","onEvent","filter","e","onMessageTrigger","NEXT","afterStorageImport","thru","STORAGE_IMPORTED","stream","home","DC_DETECTED","rootEpic"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\n\nimport { combineEpics } from 'redux-most'\nimport { Stream } from 'most'\nimport { contains } from 'ramda'\nimport { type UID, type DCNumber } from 'Newtype'\nimport { MAIN, API } from 'Action'\nimport netRequest, { onNewTask } from './net-request'\nimport { receiveResponse } from './task'\nimport { authRequest } from '../../service/invoke'\nimport {\n  getClient,\n  getHomeStatus,\n  queryKeys,\n} from '../query'\nimport type {\n  Client\n} from '../index.h'\nimport { dispatch } from '../portal'\nimport { KeyValue } from 'Monad'\nimport { trimType } from '../helpers'\n// import Config from 'ConfigProvider'\n\nconst filterActions = (list: string[]) => action => contains(\n  trimType(action.type),\n  list\n)\n\nconst Blackhole = {\n  //$off\n  action(state: {\n    ...Client,\n    status: KeyValue<DCNumber, boolean>\n  }, action: {\n    uid: UID,\n    type: string,\n    payload: mixed\n  }) {\n    const { homeDc, status } = state\n    const statusObj = status.toJSON()\n    const type = trimType(action.type)\n    if (__DEV__)\n      console.log(type, state)\n    switch (type) {\n      case 'api/request new': {\n        if (__DEV__)\n          //$off\n          console.warn(statusObj[homeDc])\n        dispatch(API.TASK.NEW([action.payload.netReq]), action.uid)\n        break\n      }\n      case 'main/auth resolve': {\n        dispatch(API.TASK.NEW(state.request.values), action.uid)\n        break\n      }\n      case 'main/dc detected': {\n        const uid: string = action.payload.uid\n        const dc: number = action.payload.dc\n        const homeStatus = getHomeStatus(uid)\n        const keys = queryKeys(uid, dc)\n          .map(({ dc, uid, auth, authID, salt }) => ({\n            dc, uid,\n            authKey   : auth,\n            authKeyID : authID,\n            serverSalt: salt,\n          }))\n          .fold(() => false, x => x)\n        if (homeStatus && keys) {\n          dispatch(MAIN.AUTH.RESOLVE(keys), uid)\n        } else {\n          authRequest(uid, dc).promise()\n        }\n      }\n    }\n  }\n}\n\nconst onEvent = (action: Stream<any>) => action\n  .filter(e => !!e.uid)\n  .map(e => getClient(e.uid).map(state => Blackhole.action(state, e)))\n  .filter(() => false)\n\nconst onMessageTrigger = (action: Stream<any>) => action\n  .filter(e => !!e.uid)\n  .filter(filterActions([\n    'api/request new',\n    'main/auth resolve',\n    'api/task new',\n    'api/task done'\n  ]))\n  .map(({ uid }: { uid: string }) => uid)\n  .filter(getHomeStatus)\n  .map(uid => dispatch(API.NEXT({ uid }), uid))\n  .filter(() => false)\n\nconst afterStorageImport = (action: Stream<{ type: string, payload: any }>) => action\n  .thru(MAIN.STORAGE_IMPORTED.stream)\n  .map(e => e.payload)\n  .map(({ home, uid }) => ({ dc: home, uid }))\n  .map(MAIN.DC_DETECTED)\n\nconst rootEpic = combineEpics([\n  afterStorageImport,\n  onMessageTrigger,\n  netRequest,\n  receiveResponse,\n  onEvent,\n  onNewTask,\n])\n\nexport default rootEpic\n"]}