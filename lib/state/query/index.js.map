{"version":3,"sources":["../../../src/state/query/index.js"],"names":["getClient","fromNullable","resolveRequest","uid","dc","outID","map","command","chain","maybeGetK","pair","snd","queryRequest","reqID","state","request","e","client","getHomeStatus","homeStatus","fold","x","keyQuery","selector","keyStorage","getMaybe","queryHomeDc","homeDc","queryAuthID","authID","queryAuthKey","auth","querySalt","salt","queryKeys","dcʹ","traverse3","queryAck","pendingAck"],"mappings":";;;;;;QAsCgBA,S,GAAAA,S;;AAlChB;;AAEA;;AAEA;;AACA;;AAIA;;AAMA;;AAjBA;;AAmBA,IAAM,EAAEC,YAAF,mBAAN;;AAEO,IAAMC,0CAAiB,CAC5BC,GAD4B,EAE5BC,EAF4B,EAG5BC,KAH4B,KAK5BL,UAAUG,GAAV,EACGG,GADH,CACO,CAAC,EAAEC,OAAF,EAAD,KAAiBA,OADxB,EAEGC,KAFH,CAESD,WAAWA,QAAQE,SAAR,CAAkBJ,KAAlB,CAFpB,EAGGC,GAHH,CAGOI,QAAQA,KAAKC,GAAL,EAHf,CALK;;AAUA,IAAMC,sCAAe,CAACT,GAAD,EAAcC,EAAd,EAA4BC,KAA5B,KAC1BH,eAAeC,GAAf,EAAoBC,EAApB,EAAwBC,KAAxB,EACGG,KADH,CACUK,KAAD,IAAiBb,UAAUG,GAAV,EAAeK,KAAf,CAAqBM,SAASA,MAAMC,OAAN,CAAcN,SAAd,CAAwBI,KAAxB,CAA9B,CAD1B,EAEGP,GAFH,CAEOI,QAAQA,KAAKC,GAAL,EAFf,CADK;;AAKA,SAASX,SAAT,CAAmBG,GAAnB,EAA+C;AACpD,SAAOF,+BACJO,KADI,CACEQ,KAAKf,aAAae,GAAb,CADP,EAEJR,KAFI,CAEEQ,KAAKf,aAAae,EAAEC,MAAf,CAFP,EAGJT,KAHI,CAGEQ,KAAKf,aAAae,EAAEb,GAAF,CAAb,CAHP,CAAP;AAIA;AACA;AACD;;AAEM,IAAMe,wCAAiBf,GAAD,IAC3BH,UAAUG,GAAV,EACGG,GADH,CACOW,UAAUA,OAAOE,UADxB,EAEGC,IAFH,CAEQ,MAAM,KAFd,EAEqBC,KAAKA,CAF1B,CADK;;AAOP,IAAMC,WACHC,QAAD,IACE,CAACpB,GAAD,EAAWC,EAAX,KACEJ,UAAUG,GAAV,EACGG,GADH,CACOiB,QADP,EAEGf,KAFH,CAESP,YAFT,EAGGO,KAHH,CAGSgB,cAAcA,WAAWC,QAAX,CAAoBrB,EAApB,CAHvB,CAHN;AAOQ;;AAED,IAAMsB,oCACVvB,GAAD,IACEH,UAAUG,GAAV,EACGG,GADH,CACOW,UAAUA,OAAOU,MADxB,EAEGnB,KAFH,CAESP,YAFT,CAFG;AAKD;;AAEC,IAAM2B,oCAAcN,SAASL,UAAUA,OAAOY,MAA1B,CAApB;AACA,IAAMC,sCAAeR,SAASL,UAAUA,OAAOc,IAA1B,CAArB;AACA,IAAMC,gCAAYV,SAASL,UAAUA,OAAOgB,IAA1B,CAAlB;;AAEA,IAAMC,gCAAY,CAAC/B,GAAD,EAAWC,EAAX,KACvBH,aAAaG,EAAb,EACGI,KADH,CACU2B,GAAD,IAAU,eACdC,SADc,CAEbN,aAAa3B,GAAb,EAAkBgC,GAAlB,CAFa,EAGbP,YAAYzB,GAAZ,EAAiBgC,GAAjB,CAHa,EAIbH,UAAU7B,GAAV,EAAegC,GAAf,CAJa,EAMd7B,GANc,CAMV,CAAC,CAACyB,IAAD,EAAOF,MAAP,EAAeI,IAAf,CAAD,MAA2B;AAC9B9B,KAD8B;AAE9BC,MAAI+B,GAF0B;AAG9BJ,MAH8B;AAI9BF,QAJ8B;AAK9BI;AAL8B,CAA3B,CANU,CADnB,CADK;;AAiBA,IAAMI,8BAAW,CAAClC,GAAD,EAAWC,EAAX,KACtBJ,UAAUG,GAAV,EACGG,GADH,CACOW,UAAUA,OAAOqB,UAAP,CAAkBlC,EAAlB,CADjB,EAEGI,KAFH,CAESP,YAFT,EAGGmB,IAHH,CAGQ,MAAM,EAHd,EAGkBC,KAAKA,CAHvB,CADK","file":"index.js","sourcesContent":["//@flow\n\n// import { fromNullable, Maybe } from 'folktale/maybe'\n\nimport { Maybe } from 'apropos'\n\nimport { MaybeT } from 'Monad'\n\nimport { getState } from '../portal'\nimport {\n  type Client,\n} from '../index.h'\n\nimport {\n  type DCNumber,\n  type UID,\n  toCryptoKey,\n  toDCNumber,\n} from 'Newtype'\nimport { KeyStorage } from 'Util/key-storage'\n\nconst { fromNullable } = Maybe\n\nexport const resolveRequest = (\n  uid: string,\n  dc: DCNumber,\n  outID: string\n): Maybe<string> =>\n  getClient(uid)\n    .map(({ command }) => command)\n    .chain(command => command.maybeGetK(outID))\n    .map(pair => pair.snd())\n\nexport const queryRequest = (uid: string, dc: DCNumber, outID: string) =>\n  resolveRequest(uid, dc, outID)\n    .chain((reqID: $off) => getClient(uid).chain(state => state.request.maybeGetK(reqID)))\n    .map(pair => pair.snd())\n\nexport function getClient(uid: string): Maybe<Client> {\n  return fromNullable(getState)\n    .chain(e => fromNullable(e()))\n    .chain(e => fromNullable(e.client))\n    .chain(e => fromNullable(e[uid]))\n  // const { client } = getState()\n  // return fromNullable(client[uid])\n}\n\nexport const getHomeStatus = (uid: string) =>\n  getClient(uid)\n    .map(client => client.homeStatus)\n    .fold(() => false, x => x)\n\ntype KeySelector = (x: Client) => KeyStorage\n\nconst keyQuery =\n  (selector: KeySelector) =>\n    (uid: UID, dc: DCNumber) =>\n      getClient(uid)\n        .map(selector)\n        .chain(fromNullable)\n        .chain(keyStorage => keyStorage.getMaybe(dc))\n        /*:: .map(toCryptoKey) */\n\nexport const queryHomeDc =\n  (uid: UID) =>\n    getClient(uid)\n      .map(client => client.homeDc)\n      .chain(fromNullable)\n      /*:: .map(toDCNumber) */\n\nexport const queryAuthID = keyQuery(client => client.authID)\nexport const queryAuthKey = keyQuery(client => client.auth)\nexport const querySalt = keyQuery(client => client.salt)\n\nexport const queryKeys = (uid: UID, dc: DCNumber) =>\n  fromNullable(dc)\n    .chain((dcʹ) =>  MaybeT\n      .traverse3(\n        queryAuthKey(uid, dcʹ),\n        queryAuthID(uid, dcʹ),\n        querySalt(uid, dcʹ)\n      )\n      .map(([auth, authID, salt]) => ({\n        uid,\n        dc: dcʹ,\n        auth,\n        authID,\n        salt,\n      })))\n\n\nexport const queryAck = (uid: UID, dc: DCNumber) =>\n  getClient(uid)\n    .map(client => client.pendingAck[dc])\n    .chain(fromNullable)\n    .fold(() => [], x => x)\n"]}