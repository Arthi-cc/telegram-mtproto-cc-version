{"version":3,"sources":["../../src/tl/writer.js"],"names":["writeInt","writeBool","writeLongP","writeLong","writeDouble","writeBytes","writeIntBytes","ctx","i","field","iHigh","iLow","writePair","sLong","Array","isArray","length","str","toString","int1","int2","f","buffer","ArrayBuffer","intView","Int32Array","doubleView","Float64Array","bytes","list","binaryDataGuard","checkLength","next","set","addPadding","bits","console","warn","trace","Error","Uint8Array","byteLength","unescape","encodeURIComponent","undefined"],"mappings":"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","file":"writer.js","sourcesContent":["//@flow\n\nimport { TypeWriter } from './type-buffer'\nimport { longToInts, stringToChars } from '../bin'\n\n// import Logger from 'mtproto-logger'\n// const log = Logger`tl:writer`\n\nimport type { BinaryData } from './index.h'\n\n\nexport function writeInt(ctx: TypeWriter, i: number, field: string = '') {\n  ctx.writeInt(i, `${ field }:int`)\n}\n\nexport function writeBool(ctx: TypeWriter, i: boolean, field: string = '') {\n  if (i) {\n    ctx.writeInt(0x997275b5, `${ field }:bool`)\n  } else {\n    ctx.writeInt(0xbc799737, `${ field }:bool`)\n  }\n}\n\nexport function writeLongP(ctx: TypeWriter,\n                           iHigh: number,\n                           iLow: number,\n                           field: string) {\n  ctx.writePair(iLow, iHigh,\n                `${ field }:long[low]`,\n                `${ field }:long[high]`)\n}\n\nexport function writeLong(ctx: TypeWriter,\n                          sLong?: number[] | string | number,\n                          field: string = '') {\n  if (Array.isArray(sLong))\n    return sLong.length === 2\n        ? writeLongP(ctx, sLong[0], sLong[1], field)\n        : writeIntBytes(ctx, sLong, 64)\n  let str\n  if (typeof sLong !== 'string')\n    str = sLong\n        ? sLong.toString()\n        : '0'\n  else str = sLong\n  const [int1, int2] = longToInts(str)\n  ctx.writePair(int2, int1,\n                `${ field }:long[low]`,\n                `${ field }:long[high]`)\n}\n\nexport function writeDouble(ctx: TypeWriter,\n                            f: number,\n                            field: string = '') {\n  const buffer = new ArrayBuffer(8)\n  const intView = new Int32Array(buffer)\n  const doubleView = new Float64Array(buffer)\n\n  doubleView[0] = f\n\n  const [int1, int2] = intView\n  ctx.writePair(int2, int1,\n                `${ field }:double[low]`,\n                `${ field }:double[high]`)\n}\n\nexport function writeBytes(ctx: TypeWriter,\n                           bytes?: number[] | ArrayBuffer | string,\n                           /*field: string = ''*/) {\n  const { list, length } = binaryDataGuard(bytes)\n    // debug && console.log('>>>', bytesToHex(bytes), `${ field }:bytes`)\n\n  ctx.checkLength(length + 8)\n  if (length <= 253) {\n    ctx.next(length)\n  } else {\n    ctx.next(254)\n    ctx.next(length & 0xFF)\n    ctx.next((length & 0xFF00) >> 8)\n    ctx.next((length & 0xFF0000) >> 16)\n  }\n\n  ctx.set(list, length)\n  ctx.addPadding()\n}\n\nexport function writeIntBytes(ctx: TypeWriter,\n                              bytes: BinaryData  | ArrayBuffer | string,\n                              bits: number | false,\n                              /*field: string = ''*/) {\n  const { list, length } = binaryDataGuard(bytes)\n\n  if (bits) {\n    if (bits % 32 || length * 8 != bits) {\n      console.warn(bits)\n      console.trace()\n      throw new Error(`Invalid bits: ${  bits  }, ${length}`)\n    }\n  }\n  // debug && console.log('>>>', bytesToHex(bytes), `${ field }:int${  bits}`)\n  ctx.checkLength(length)\n  ctx.set(list, length)\n}\n\n\nconst binaryDataGuard = (bytes?: number[] | ArrayBuffer | Uint8Array | string) => {\n  let list, length\n  if (bytes instanceof ArrayBuffer) {\n    list = new Uint8Array(bytes)\n    length = bytes.byteLength\n  } else if (typeof bytes === 'string') {\n    list =\n      stringToChars(\n        unescape(\n          encodeURIComponent(\n            bytes)))\n    length = list.length\n  } else if (bytes === undefined) {\n    list = []\n    length = 0\n  } else {\n    list = bytes\n    length = bytes.length\n  }\n  return {\n    list,\n    length\n  }\n}"]}