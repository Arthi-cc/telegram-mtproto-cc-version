{"version":3,"sources":["../../../src/util/profunctor/trampoline.js"],"names":["applyStack","Trampoline","run","x","stack","append","fn","prepend","concat","snd","fst","empty","constructor","of","data","ln","length","current","val","i"],"mappings":";;;;;QAwCgBA,U,GAAAA,U;;AAtChB;;AAMA,MAAMC,UAAN,CAAuB;AAErBC,MAAIC,CAAJ,EAAa;AACX,WAAOH,WAAW,KAAKI,KAAhB,EAAuBD,CAAvB,CAAP;AACD;AACDE,SAAWC,EAAX,EAAgD;AAC9C,WAAO,IAAIL,UAAJ,CAAe,qBAAOK,EAAP,EAAW,KAAKF,KAAhB,CAAf,CAAP;AACD;AACDG,UAAYD,EAAZ,EAAiD;AAC/C,WAAO,IAAIL,UAAJ,CAAe,mBAAKK,EAAL,EAAS,KAAKF,KAAd,CAAf,CAAP;AACD;AACDI,SAAWC,GAAX,EAAsD;AACpD,WAAOR,WAAWO,MAAX,CAAkB,IAAlB,EAAwBC,GAAxB,CAAP;AACD;;AAED,SAAOD,MAAP,CACEE,GADF,EAEED,GAFF,EAGsB;AACpB,WAAO,IAAIR,UAAJ,CAAe,yBAAWS,IAAIN,KAAf,EAAsBK,IAAIL,KAA1B,CAAf,CAAP;AACD;AACD,SAAOO,KAAP,GAA0C;AACxC,WAAO,IAAIV,UAAJ,CAAe,CAAEE,CAAD,IAAOA,CAAR,CAAf,CAAP;AACD;;AAEDS,cAAYR,KAAZ,EAAgC;AAAE,SAAKA,KAAL,GAAaA,KAAb;AAAoB;AACtD,SAAOS,EAAP,CAAkBT,KAAlB,EAA4D;AAC1D,WAAO,IAAIH,UAAJ,CAAeG,KAAf,CAAP;AACD;AA5BoB;;kBAAjBH,U;AAgCC,SAASD,UAAT,CAA0BI,KAA1B,EAA8CU,IAA9C,EAA0D;AAC/D,MAAMC,KAAKX,MAAMY,MAAjB;AACA,MAAID,OAAO,CAAX,EACE,OAAQD,IAAR;AACF,MAAIG,UAAUH,IAAd;AAAA,MAAoBR,WAApB;AAAA,MAAwBY,YAAxB;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIJ,EAApB,EAAwB,EAAEI,CAA1B,EAA6B;AAC3Bb,SAAKF,MAAMe,CAAN,CAAL;AACAD,UAAMZ,GAAGW,OAAH,CAAN;AACAA,cAAUC,GAAV;AACD;AACD,SAAQD,OAAR;AACD","file":"trampoline.js","sourcesContent":["//@flow\n\nimport { cons, append, concatPair } from './prelude'\n\nexport\ntype Stack<I, O> = Array<(val: any) => any>\n\nexport default\nclass Trampoline<I, O> {\n  stack: Stack<I, O>\n  run(x: I): O {\n    return applyStack(this.stack, x)\n  }\n  append<OB>(fn: (x: O) => OB): Trampoline<I, OB> {\n    return new Trampoline(append(fn, this.stack))\n  }\n  prepend<IB>(fn: (x: IB) => I): Trampoline<IB, O> {\n    return new Trampoline(cons(fn, this.stack))\n  }\n  concat<OB>(snd: Trampoline<O, OB>): Trampoline<I, OB> {\n    return Trampoline.concat(this, snd)\n  }\n\n  static concat<IA, OA, OB>(\n    fst: Trampoline<IA, OA>,\n    snd: Trampoline<OA, OB>,\n  ): Trampoline<IA, OB> {\n    return new Trampoline(concatPair(fst.stack, snd.stack))\n  }\n  static empty<Any>(): Trampoline<Any, Any> {\n    return new Trampoline([(x) => x])\n  }\n\n  constructor(stack: Stack<I, O>) { this.stack = stack }\n  static of<I1, O1>(stack: Stack<I1, O1>): Trampoline<I1, O1> {\n    return new Trampoline(stack)\n  }\n}\n\n\nexport function applyStack<I, O>(stack: Stack<I, O>, data: I): O {\n  const ln = stack.length\n  if (ln === 0)\n    return (data: $FlowIssue)\n  let current = data, fn, val\n  for (let i = 0; i < ln; ++i) {\n    fn = stack[i]\n    val = fn(current)\n    current = val\n  }\n  return (current: $FlowIssue)\n}\n"]}