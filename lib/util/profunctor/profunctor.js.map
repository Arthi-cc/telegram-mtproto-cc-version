{"version":3,"sources":["../../../src/util/profunctor/profunctor.js"],"names":["Profunctor","before","λ","pre","undefined","of","after","post","inverse","promap","ofArrow","bimap","ap","fn","fnStack","fullStack","constructor","Object","defineProperty","value","enumerable","writable","val","stack","Array","isArray","TypeError"],"mappings":";;;;;;AAEA;;AACA;;;;AACA;;;;;;AASA;;;;;;;;;;;;AAaA,MAAMA,UAAN,CAA6B;AAO3BC,WAAsB;AACpB,QAAI,KAAKC,CAAL,CAAOC,GAAP,KAAeC,SAAnB,EAA8B;AAC5B,WAAKF,CAAL,CAAOC,GAAP,GAAa,gBAAME,EAAN,CAAS,KAAKF,GAAd,CAAb;AACD;AACD,WAAO,KAAKD,CAAL,CAAOC,GAAd;AACD;AACDG,UAAqB;AACnB,QAAI,KAAKJ,CAAL,CAAOK,IAAP,KAAgBH,SAApB,EAA+B;AAC7B,WAAKF,CAAL,CAAOK,IAAP,GAAc,gBAAMF,EAAN,CAAS,KAAKE,IAAd,CAAd;AACD;AACD,WAAO,KAAKL,CAAL,CAAOK,IAAd;AACD;AACD;;;;;;AAMAC,YAAkC;AAChC,WAAO,IAAIR,UAAJ,CACL,KAAKO,IADA,EAEL,KAAKJ,GAFA,CAAP;AAID;;AAED;;;;;;;;;;;AAWAM,SAA8DN,GAA9D,EAAwEI,IAAxE,EAA8G;AAC5G,WAAO,IAAIP,UAAJ,CACL,yBAAWU,QAAQP,GAAR,CAAX,EAAyB,KAAKA,GAA9B,CADK,EAEL,yBAAW,KAAKI,IAAhB,EAAsBG,QAAQH,IAAR,CAAtB,CAFK,CAAP;AAID;;AAED;;;;;;;;;;;AAWAI,QAA6DR,GAA7D,EAAuEI,IAAvE,EAA6G;AAC3G,WAAO,IAAIP,UAAJ,CACL,yBAAW,KAAKG,GAAhB,EAAqBO,QAAQP,GAAR,CAArB,CADK,EAEL,yBAAWO,QAAQH,IAAR,CAAX,EAA0B,KAAKA,IAA/B,CAFK,CAAP;AAID;;AAEDK,KAAwBC,EAAxB,EAA6C;AAC3C,QAAMC,UAAUJ,QAAQG,EAAR,CAAhB;AACA,QAAME,YAAyB,qBAAO,CAAC,KAAKZ,GAAN,EAAWW,OAAX,EAAoB,KAAKP,IAAzB,CAAP,CAA/B;AACA,WAAO,gBAAMF,EAAN,CAASU,SAAT,CAAP;AACD;;AAEDC,cAAYb,GAAZ,EAA8BI,IAA9B,EAAiD;AAC/C,SAAKJ,GAAL,GAAWA,GAAX;AACA,SAAKI,IAAL,GAAWA,IAAX;AACA;AACAU,WAAOC,cAAP,CAAsB,IAAtB,EAA4B,GAA5B,EAAiC;AAC/BC,aAAY,EADmB;AAE/BC,kBAAY,KAFmB;AAG/BC,gBAAY;AAHmB,KAAjC;AAKD;AACD,SAAOhB,EAAP,CAIEF,GAJF,EAIYI,IAJZ,EAIoD;AAClD,WAAO,IAAIP,UAAJ,CAAeU,QAAQP,GAAR,CAAf,EAA6BO,QAAQH,IAAR,CAA7B,CAAP;AACD;AA1F0B;;kBAAvBP,U;AA6FN,SAASU,OAAT,CAAuBY,GAAvB,EAA0D;AACxD,MAAIA,8BAAJ,EAA0B;AACxB,WAAOA,IAAIpB,CAAJ,CAAMqB,KAAb;AACD,GAFD,MAEO,IAAI,OAAOD,GAAP,KAAe,UAAnB,EAA+B;AAEpC,WAD2B,CAACA,GAAD,CAC3B;AACD,GAHM,MAGA,IAAIE,MAAMC,OAAN,CAAcH,GAAd,CAAJ,EAAwB;AAC7B,WAAOA,GAAP;AACD,GAFM,MAEA,IAAIA,mCAAJ,EAA+B;AACpC,WAAOA,IAAIC,KAAX;AACD,GAFM,MAEA,MAAM,IAAIG,SAAJ,CAAe,kBAAf,CAAN;AACR;;AAED;;;;;;;;;;AAUA","file":"profunctor.js","sourcesContent":["//@flow\n\nimport { append, concat, concatPair } from './prelude'\nimport Arrow from './arrow'\nimport Trampoline from './trampoline'\nimport { type Stack } from './trampoline'\nimport { type ArrowType } from './arrow'\n\nexport\ntype ProfunctorType<A, B, I, O> =\n  | Profunctor<A, B, I, O>\n  | [Arrow<I, A>, Arrow<B, O>]\n\n/**\n * Basically, this is a pair of functions:\n * *before* transformation and *after*\n *\n * Transformation is any function from `A` to `B`\n *\n * @class Profunctor\n * @template A Transformation input\n * @template B Transformation output\n * @template I Main input\n * @template O Results output\n */\nexport default\nclass Profunctor<A, B, I, O> {\n  pre: Stack<I, A>\n  post: Stack<B, O>\n  λ: {\n    pre: Arrow<I, A>,\n    post: Arrow<B, O>\n  }\n  before(): Arrow<I, A> {\n    if (this.λ.pre === undefined) {\n      this.λ.pre = Arrow.of(this.pre)\n    }\n    return this.λ.pre\n  }\n  after(): Arrow<B, O> {\n    if (this.λ.post === undefined) {\n      this.λ.post = Arrow.of(this.post)\n    }\n    return this.λ.post\n  }\n  /**\n   * Turns a Profunctor around\n   *\n   * @returns {Profunctor<O, I, B, A>}\n   * @memberof Profunctor\n   */\n  inverse(): Profunctor<O, I, B, A> {\n    return new Profunctor(\n      this.post,\n      this.pre\n    )\n  }\n\n  /**\n   * *Extends* a Profunctor by prepending\n   *  new function *before* and appending *after*\n   *\n   * @param {ArrowType<I1, I>} pre\n   * @param {ArrowType<O, O1>} post\n   * @template I1\n   * @template O1\n   * @memberof Profunctor\n   * @returns {Profunctor<A, B, I1, O1>}\n   */\n  promap<I1, O1, Pre: ArrowType<I1, I>, Post: ArrowType<O, O1>>(pre: Pre, post: Post): Profunctor<A, B, I1, O1> {\n    return new Profunctor(\n      concatPair(ofArrow(pre), this.pre),\n      concatPair(this.post, ofArrow(post))\n    )\n  }\n\n  /**\n   * *Change* a Profunctor by wrapping\n   *  new type into transformation\n   *\n   * @param {ArrowType<A, A1>} pre\n   * @param {ArrowType<B1, B>} post\n   * @template A1\n   * @template B1\n   * @memberof Profunctor\n   * @returns {Profunctor<A1, B1, I, O>}\n   */\n  bimap<A1, B1, Pre: ArrowType<A, A1>, Post: ArrowType<B1, B>>(pre: Pre, post: Post): Profunctor<A1, B1, I, O> {\n    return new Profunctor(\n      concatPair(this.pre, ofArrow(pre)),\n      concatPair(ofArrow(post), this.post)\n    )\n  }\n\n  ap<Fn: ArrowType<A, B>>(fn: Fn): Arrow<I, O> {\n    const fnStack = ofArrow(fn)\n    const fullStack: Stack<I, O> = concat([this.pre, fnStack, this.post])\n    return Arrow.of(fullStack)\n  }\n\n  constructor(pre: Stack<I, A>, post: Stack<B, O>) {\n    this.pre = pre\n    this.post= post\n    //$FlowIssue\n    Object.defineProperty(this, 'λ', {\n      value     : {},\n      enumerable: false,\n      writable  : true\n    })\n  }\n  static of<\n    A1, B1, I1, O1,\n    Pre: ArrowType<I1, A1>,\n    Post: ArrowType<B1, O1>\n  >(pre: Pre, post: Post): Profunctor<A1, B1, I1, O1> {\n    return new Profunctor(ofArrow(pre), ofArrow(post))\n  }\n}\n\nfunction ofArrow<I, O>(val: ArrowType<I, O>): Stack<I, O> {\n  if (val instanceof Arrow) {\n    return val.λ.stack\n  } else if (typeof val === 'function') {\n    const stack: Stack<I, O> = [val]\n    return stack\n  } else if (Array.isArray(val)) {\n    return val\n  } else if (val instanceof Trampoline) {\n    return val.stack\n  } else throw new TypeError(`wrong arrow-like`)\n}\n\n/**\n * Like standart Profunctor, but with reduce inside\n *\n * @class Costar\n * @extends {Profunctor<A[], B[], I, O>}\n * @template A\n * @template B\n * @template I\n * @template O\n */\n/*export class Costar<A, B, AL: A[], BL: B[], I, O> extends Profunctor<AL, BL, I, O> {\n  reduce<Fn: ArrowType<A, B>>(fn: Fn): Arrow<I, O> {\n    const arrow: Arrow<A, B> = Arrow.of(fn)\n    const reducer = (acc: B[], val: A) => append(arrow.ap(val), acc)\n    function reduceFn(source: AL): BL {\n      const empty: BL = ([]: any)\n      return source.reduce(reducer, empty)\n    }\n    const reduceArrow: Arrow<AL, BL> = Arrow.of(reduceFn)\n    return this.pre\n      .compose(reduceArrow)\n      .compose(this.post)\n  }\n\n  static of<\n    A1, B1, AL1: A1[], BL1: B1[], I1, O1,\n    Pre: ArrowType<I1, A1[]>,\n    Post: ArrowType<B1[], O1>\n  >(pre: Pre, post: Post): Costar<A1, B1, AL1, BL1, I1, O1> {\n    //$ FlowIssue\n    return new Costar(Arrow.of(pre), Arrow.of(post))\n  }\n}*/\n\n"]}