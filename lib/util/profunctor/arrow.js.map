{"version":3,"sources":["../../../src/util/profunctor/arrow.js"],"names":["Arrow","constructor","λ","fn","arrow","run","stack","ap","x","map","append","contramap","prepend","bimap","pre","post","compose","concat","of","val","isFunc","ofFunc","isStack","ofStack","isTrampoline","ofTrampoline","isArrow","ofArrow","TypeError","id","data","Array","isArray"],"mappings":";;;;;;AAEA;;;;;;AAWA,MAAMA,KAAN,CAAkB;AAEhBC,cAAYC,CAAZ,EAAiC;AAC/B,SAAKA,CAAL,GAASA,CAAT;AACD;AACDC,OAAK;AACH;AACA,QAAMC,QAAqBC,IAAI,KAAKH,CAAL,CAAOI,KAAX,CAA3B;AACA,WAAOF,KAAP;AACD;AACDG,KAAGC,CAAH,EAAY;AACV,WAAO,KAAKN,CAAL,CAAOG,GAAP,CAAWG,CAAX,CAAP;AACD;AACDC,MAAQN,EAAR,EAAwC;AACtC,WAAO,IAAIH,KAAJ,CAAU,KAAKE,CAAL,CAAOQ,MAAP,CAAcP,EAAd,CAAV,CAAP;AACD;AACDQ,YAAcR,EAAd,EAA8C;AAC5C,WAAO,IAAIH,KAAJ,CAAU,KAAKE,CAAL,CAAOU,OAAP,CAAeT,EAAf,CAAV,CAAP;AACD;AACDU,QAAcC,GAAd,EAAiCC,IAAjC,EAAoE;AAClE,WAAO,IAAIf,KAAJ,CAAU,KAAKE,CAAL,CAAOU,OAAP,CAAeE,GAAf,EAAoBJ,MAApB,CAA2BK,IAA3B,CAAV,CAAP;AACD;AACDC,UAAYZ,KAAZ,EAA+C;AAC7C,WAAO,IAAIJ,KAAJ,CAAU,KAAKE,CAAL,CAAOe,MAAP,CAAcb,MAAMF,CAApB,CAAV,CAAP;AACD;AACD,SAAOgB,EAAP,CAA0CC,GAA1C,EAAmE;AACjE,QAAIC,OAAOD,GAAP,CAAJ,EAAiB;AACf,aAAOE,OAAOF,GAAP,CAAP;AACD,KAFD,MAEO,IAAIG,QAAQH,GAAR,CAAJ,EAAkB;AACvB,aAAOI,QAAQJ,GAAR,CAAP;AACD,KAFM,MAEA,IAAIK,aAAaL,GAAb,CAAJ,EAAuB;AAC5B,aAAOM,aAAaN,GAAb,CAAP;AACD,KAFM,MAEA,IAAIO,QAAQP,GAAR,CAAJ,EAAkB;AACvB,aAAOQ,QAAQR,GAAR,CAAP;AACD,KAFM,MAEA;AACL,YAAM,IAAIS,SAAJ,CAAe,6BAA4B,OAAOT,GAAI,IAAGA,GAAI,EAA7D,CAAN;AACD;AACF;AACD,SAAOU,EAAP,GAA4B;AAC1B,WAAO7B,MAAMkB,EAAN,CAAUV,CAAD,IAAUA,CAAnB,CAAP;AACD;AAxCe;;kBAAZR,K;AA2CN,SAASK,GAAT,CAAmBC,KAAnB,EAAuC;AACrC,SAAO,SAASF,KAAT,CAAe0B,IAAf,EAAwB;AAC7B,WAAO,4BAAWxB,KAAX,EAAkBwB,IAAlB,CAAP;AACD,GAFD;AAGD;;AAED,SAASN,YAAT,CAAsBL,GAAtB,EAAmD;AACjD,SAAOA,mCAAP;AACD;;AAED,SAASG,OAAT,CAAiBH,GAAjB,EAA8C;AAC5C,SAAOY,MAAMC,OAAN,CAAcb,GAAd,CAAP;AACD;;AAED,SAASC,MAAT,CAAgBD,GAAhB,EAA6C;AAC3C,SAAO,OAAOA,GAAP,KAAe,UAAtB;AACD;;AAED,SAASO,OAAT,CAAiBP,GAAjB,EAA8C;AAC5C,SAAOA,eAAenB,KAAtB;AACD;;AAED,SAASyB,YAAT,CAA4BN,GAA5B,EAAgE;AAC9D,SAAO,IAAInB,KAAJ,CAAUmB,GAAV,CAAP;AACD;;AAED,SAASI,OAAT,CAAuBJ,GAAvB,EAAsD;AACpD,SAAO,IAAInB,KAAJ,CAAU,qBAAWkB,EAAX,CAAcC,GAAd,CAAV,CAAP;AACD;;AAED,SAASE,MAAT,CAAsBF,GAAtB,EAAqD;AAEnD,SAAO,IAAInB,KAAJ,CAAU,qBAAWkB,EAAX,CADU,CAACC,GAAD,CACV,CAAV,CAAP;AACD;;AAED,SAASQ,OAAT,CAAuBR,GAAvB,EAAsD;AACpD,SAAOA,GAAP;AACD","file":"arrow.js","sourcesContent":["//@flow\n\nimport Trampoline, { applyStack } from './trampoline'\nimport { type Stack } from './trampoline'\n\nexport\ntype ArrowType<I, O> =\n  | Trampoline<I, O>\n  | Stack<I, O>\n  | Arrow<I, O>\n  | ((x: I) => O)\n\nexport default\nclass Arrow<I, O> {\n  λ: Trampoline<I, O>\n  constructor(λ: Trampoline<I, O>) {\n    this.λ = λ\n  }\n  fn() {\n    //$FlowIssue\n    const arrow: (x: I) => O = run(this.λ.stack)\n    return arrow\n  }\n  ap(x: I): O {\n    return this.λ.run(x)\n  }\n  map<O1>(fn: (x: O) => O1): Arrow<I, O1> {\n    return new Arrow(this.λ.append(fn))\n  }\n  contramap<I1>(fn: (x: I1) => I): Arrow<I1, O> {\n    return new Arrow(this.λ.prepend(fn))\n  }\n  bimap<I1, O1>(pre: (x: I1) => I, post: (x: O) => O1): Arrow<I1, O1> {\n    return new Arrow(this.λ.prepend(pre).append(post))\n  }\n  compose<O1>(arrow: Arrow<O, O1>): Arrow<I, O1> {\n    return new Arrow(this.λ.concat(arrow.λ))\n  }\n  static of<I1, O1, Val: ArrowType<I1, O1>>(val: Val): Arrow<I1, O1> {\n    if (isFunc(val)) {\n      return ofFunc(val)\n    } else if (isStack(val)) {\n      return ofStack(val)\n    } else if (isTrampoline(val)) {\n      return ofTrampoline(val)\n    } else if (isArrow(val)) {\n      return ofArrow(val)\n    } else {\n      throw new TypeError(`Can not create arrow from ${typeof val} ${val}`)\n    }\n  }\n  static id<C>(): Arrow<C, C> {\n    return Arrow.of((x: C) => x)\n  }\n}\n\nfunction run<I, O>(stack: Stack<I, O>) {\n  return function arrow(data: I) {\n    return applyStack(stack, data)\n  }\n}\n\nfunction isTrampoline(val: mixed): boolean %checks {\n  return val instanceof Trampoline\n}\n\nfunction isStack(val: mixed): boolean %checks {\n  return Array.isArray(val)\n}\n\nfunction isFunc(val: mixed): boolean %checks {\n  return typeof val === 'function'\n}\n\nfunction isArrow(val: mixed): boolean %checks {\n  return val instanceof Arrow\n}\n\nfunction ofTrampoline<I, O>(val: Trampoline<I, O>): Arrow<I, O> {\n  return new Arrow(val)\n}\n\nfunction ofStack<I, O>(val: Stack<I, O>): Arrow<I, O> {\n  return new Arrow(Trampoline.of(val))\n}\n\nfunction ofFunc<I, O>(val: (x: I) => O): Arrow<I, O> {\n  const stack: Stack<I, O> = [val]\n  return new Arrow(Trampoline.of(stack))\n}\n\nfunction ofArrow<I, O>(val: Arrow<I, O>): Arrow<I, O> {\n  return val\n}\n"]}