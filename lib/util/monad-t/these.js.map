{"version":3,"sources":["../../../src/util/monad-t/these.js"],"names":["Just","Nothing","TheseCore","map","f","bimap","x","This","constructor","left","right","cata","obj","fn","That","y","g","Both","typeID","These","of","thisOrBoth","fold","b","thatOrBoth","a"],"mappings":"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","file":"these.js","sourcesContent":["//@flow\n\n// import { Maybe, Just, Nothing } from 'folktale/maybe'\nimport { Maybe } from 'apropos'\nconst { Just, Nothing } = Maybe\n\nimport {\n  ᐸMapᐳ,\n  ᐸOfᐳ,\n  λMap,\n} from './index.h'\n\nexport interface λThese<A, B> extends λMap<'These', B> {\n  typeName: 'These',\n  map<Bʹ>(f: (y: B) => Bʹ): λThese<A, Bʹ>,\n  bimap<Aʹ, Bʹ>(f: (x: A) => Aʹ, g: (y: B) => Bʹ): λThese<Aʹ, Bʹ>,\n  left(): Maybe<A>,\n  right(): Maybe<B>,\n  cata<X, Y, Z>(variants: {\n    /*:: +*/This: (x: A) => X,\n    /*:: +*/That: (y: B) => Y,\n    /*:: +*/Both: (x: A, y: B) => Z,\n  }): X | Y | Z,\n}\n\nclass TheseCore<A, B> {\n  map<Bʹ>(f: (y: B) => Bʹ): λThese<A, Bʹ> {\n    return this.bimap(x => x, f)\n  }\n  /*::\n  bimap<Aʹ, Bʹ>(f: (x: A) => Aʹ, g: (y: B) => Bʹ): λThese<Aʹ, Bʹ> {\n    declare var ret: λThese<Aʹ, Bʹ>\n    return ret\n  }\n  */\n}\n\nclass This<A, B>\n  extends TheseCore<A, B>\n  implements\n    λThese<A, B>,\n    λMap<'These', B> {\n  /*:: +*/x: A\n  typeName: 'These'\n  constructor(x: A) {\n    super()\n    this.x /*:: ; const xx*/ = x\n  }\n  bimap<Aʹ, Bʹ>(\n    f: (x: A) => Aʹ /*::,\n    g: (y: B) => Bʹ*/\n  ): λThese<Aʹ, Bʹ> {\n    return new This(f(this.x))\n  }\n  left(): Maybe<A> {\n    return Just(this.x)\n  }\n  right(): Maybe<B> {\n    return Nothing()\n  }\n  cata<X, Y, Z>(obj: {\n    /*:: +*/This: (x: A) => X,\n    /*:: +*/That: (y: B) => Y,\n    /*:: +*/Both: (x: A, y: B) => Z,\n  }): X | Y | Z {\n    const { This: fn } = obj\n    return /*:: addTypes( */ fn(this.x) /*:: ) */\n  }\n}\n\nclass That<A, B>\n  extends TheseCore<A, B>\n  implements\n    λThese<A, B>,\n    λMap<'These', B> {\n  /*:: +*/y: B\n  typeName: 'These'\n  constructor(y: B) {\n    super()\n    this.y /*:: ; const xx*/ = y\n  }\n  bimap<Aʹ, Bʹ>(f: (x: A) => Aʹ, g: (y: B) => Bʹ): λThese<Aʹ, Bʹ> {\n    return new That(g(this.y))\n  }\n  left(): Maybe<A> {\n    return Nothing()\n  }\n  right(): Maybe<B> {\n    return Just(this.y)\n  }\n  cata<X, Y, Z>(obj: {\n    /*:: +*/This: (x: A) => X,\n    /*:: +*/That: (y: B) => Y,\n    /*:: +*/Both: (x: A, y: B) => Z,\n  }): X | Y | Z {\n    const { That: fn } = obj\n    return /*:: addTypes( */ fn(this.y) /*:: ) */\n  }\n}\n\nclass Both<A, B>\n  extends TheseCore<A, B>\n  implements\n    λThese<A, B>,\n    λMap<'These', B> {\n  /*:: +*/x: A\n  /*:: +*/y: B\n  typeName: 'These'\n  constructor(x: A, y: B) {\n    super()\n    this.x /*:: ; const xx*/ = x\n    this.y /*:: ; const yy*/ = y\n  }\n  bimap<Aʹ, Bʹ>(f: (x: A) => Aʹ, g: (y: B) => Bʹ): λThese<Aʹ, Bʹ> {\n    return new Both(f(this.x), g(this.y))\n  }\n  left(): Maybe<A> {\n    return Just(this.x)\n  }\n  right(): Maybe<B> {\n    return Just(this.y)\n  }\n  cata<X, Y, Z>(obj: {\n    /*:: +*/This: (x: A) => X,\n    /*:: +*/That: (y: B) => Y,\n    /*:: +*/Both: (x: A, y: B) => Z,\n  }): X | Y | Z {\n    const { Both: fn } = obj\n    return /*:: addTypes( */ fn(this.x, this.y) /*:: ) */\n  }\n}\n\nconst typeID = 'zero-bias/These@1'\n\nexport const These: (\n  & ᐸMapᐳ<'These'>\n  & ᐸOfᐳ<'These'>\n) = {\n  '@@type': typeID,\n  This<A, +B>(x: A): λThese<A, B> {\n    return new This(x)\n  },\n  That<+A, B>(y: B): λThese<A, B> {\n    return new That(y)\n  },\n  Both<A, B>(x: A, y: B): λThese<A, B> {\n    return new Both(x, y)\n  },\n  of<+A, B>(y: B): λThese<A, B> {\n    return new That(y)\n  },\n  'fantasy-land/of': <+A, B>(y: B): λThese<A, B> => new That(y),\n  thisOrBoth<A, B>(x: A, y: Maybe<B>): λThese<A, B> {\n    return y.fold(\n      (): λThese<A, B> => new This(x),\n      (b): λThese<A, B> => new Both(x, b)\n    )\n  },\n  thatOrBoth<A, B>(x: B, y: Maybe<A>): λThese<A, B> {\n    return y.fold(\n      (): λThese<A, B> => new That(x),\n      (a): λThese<A, B> => new Both(a, x)\n    )\n  }\n}\n\nexport default These\n\n\n/*::\ndeclare function concatA<A, B, +Aʹ>(x: λThese<A, B>): λThese<A | Aʹ, B>\ndeclare function concatB<A, B, +Bʹ>(x: λThese<A, B>): λThese<A, B | Bʹ>\ndeclare function changeA<-A, B, +Aʹ>(x: λThese<A, B>): λThese<Aʹ, B>\ndeclare function changeB<A, -B, +Bʹ>(x: λThese<A, B>): λThese<A, Bʹ>\ndeclare function addTypes<A, +B, +C>(x: A): A | B | C\n*/\n"]}