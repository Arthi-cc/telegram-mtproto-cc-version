{"version":3,"sources":["../../../src/util/monad-t/identity.js"],"names":["empty","is","of","chainRec","ap","ChainRecNext","constructor","value","isNext","done","ChainRecDone","Identity","map","f","chain","fn","get","equals","toString","typeID","MIdentity","i","state","mapper","Object","assign"],"mappings":"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","file":"identity.js","sourcesContent":["//@flow\n\n/* eslint-disable no-whitespace-before-property */\n\nimport { toString, equals } from 'ramda'\n\nimport {\n  ᐸMapᐳ,\n  ᐸChainᐳ,\n  ᐸEmptyᐳ,\n  ᐸChainRecᐳ,\n  ᐸOfᐳ,\n  λMap,\n  λChain,\n} from './index.h'\n\nexport type ChainRec<T> = {\n  isNext: boolean,\n  value: T,\n}\n\nexport type CanBeMapped<V> = {\n  map<T>(fn: (x: V) => T): CanBeMapped<T>,\n}\n\ntype ChainRecF = <T>(x: T) => ChainRec<T>\n\ntype ChainRecIterator = <-I, O>(next: ChainRecF, done: ChainRecF, value: I) => ChainRec<O>\n\nclass ChainRecNext<T> {\n  isNext: boolean = true\n  done: boolean = false\n  value: T\n  constructor(value: T): ChainRec<T> {\n    this.value = value\n    /*:: return this */\n  }\n  static of<Tʹ>(value: Tʹ): ChainRec<Tʹ> {\n    return new ChainRecNext(value)\n  }\n}\n\nclass ChainRecDone<T> {\n  isNext: boolean = false\n  done: boolean = true\n  value: T\n  constructor(value: T): ChainRec<T> {\n    this.value = value\n    /*:: return this */\n  }\n  static of<Tʹ>(value: Tʹ): ChainRec<Tʹ> {\n    return new ChainRecDone(value)\n  }\n}\n\n/**\n * A data type that holds a value and exposes a monadic api.\n */\nexport\nclass Identity<T>\nimplements\n  λMap<'Identity', T>,\n  λChain<'Identity', T>\n{\n  typeName: 'Identity'\n  value: T\n  /**\n   * Constructs a new `Identity[a]` data type that holds a single\n   * value `a`.\n   * @param {*} a Value of any type\n   * @sig a -> Identity[a]\n   */\n  constructor(value: T) {\n    if (value instanceof ChainRecNext || value instanceof ChainRecDone)\n      this.value = value.value\n    else\n      this.value = value\n  }\n\n  /**\n   * Functor specification. Creates a new `Identity[a]` mapping function `f` onto\n   * `a` returning any value b.\n   * @param {Function} f Maps `a` to any value `b`\n   * @returns Identity[b]\n   * @sig @Identity[a] => (a -> b) -> Identity[b]\n   */\n  map<O>(f: (x: T) => O): Identity<O> {\n    return new Identity(f(this.value))\n  }\n\n  /**\n   * Chain specification. Transforms the value of the `Identity[a]`\n   * type using an unary function to monads. The `Identity[a]` type\n   * should contain a function, otherwise an error is thrown.\n   *\n   * @param {Function} fn Transforms `a` into a `Monad[b]`\n   * @returns Monad[b]\n   * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]\n   */\n  chain<Name, O>(fn: (x: T) => λChain<Name, O>): λChain<Name, O> {\n    return fn(this.value)\n  }\n\n  /**\n   * Returns the value of `Identity[a]`\n   *\n   * @returns a\n   * @sig (Identity[a]) => a\n   */\n  get(): T {\n    return this.value\n  }\n\n  equals(value: any): boolean {\n    if (value instanceof Identity)\n      return equals(this.value, value.value)\n    return equals(this.value, value)\n  }\n\n  toString() {\n    return `Identity(${  toString(this.value)  })`\n  }\n\n  static is = is\n\n  static of = of\n\n  static empty = empty\n\n  // static ap = ap\n\n  static chainRec = chainRec\n}\n\nconst typeID = 'zero-bias/Identity@1'\n\nexport const MIdentity: (\n  & ᐸMapᐳ<'Identity'>\n  & ᐸOfᐳ<'Identity'>\n  & ᐸEmptyᐳ<'Identity'>\n  & ᐸChainᐳ<'Identity'>\n  & ᐸChainRecᐳ<'Identity'>\n) = {\n  '@@type'               : typeID,\n  chainRec,\n  'fantasy-land/chainRec': chainRec,\n  of                     : <T>(value: T): Identity<T> => new Identity(value),\n  'fantasy-land/of'      : <T>(value: T): Identity<T> => new Identity(value),\n  empty                  : (): Identity<void> => new Identity(void 0),\n  'fantasy-land/empty'   : (): Identity<void> => new Identity(void 0),\n}\n\nexport function empty(): Identity<void> {\n  return new Identity(void 0)\n}\n\nexport function is(value: any): boolean {\n  return value instanceof Identity\n}\n\n/**\n * Applicative specification. Creates a new `Identity[a]` holding the value `a`.\n * @param {*} a Value of any type\n * @returns Identity[a]\n * @sig a -> Identity[a]\n */\nexport function of<Tʹ>(value: Tʹ): Identity<Tʹ> {\n  return new Identity(value)\n}\n\nexport function chainRec<Tʹ, N>(f: ChainRecIterator, i: Tʹ): Identity<N> {\n  let state = new ChainRecNext(i)\n  while (state.isNext) {\n    state = f(ChainRecNext.of, ChainRecDone.of, state.value)\n  }\n  declare var n: N\n  return new Identity((state.value /*:: , n */ ))\n}\n\n/**\n * Apply specification. Applies the function inside the `Identity[a]`\n * type to another applicative type.\n * @param {Applicative[a]} app Applicative that will apply its function\n * @returns Applicative[b]\n * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]\n */\n\nexport function ap<I, O>(mapper: Identity<((x: I) => O)>, value: CanBeMapped<I>): CanBeMapped<O> {\n  return value.map(mapper.value)\n}\n\n\n/*::  ; const dull = {} */\n\nObject.assign(/*:: dull, */ Identity, MIdentity)\n\n// //eslint-disable-next-line\n// Identity.prototype /*:: ; dull */ .ap =\n//   function(value: any) {\n//     return Identity.ap(this, value)\n//   }\n"]}