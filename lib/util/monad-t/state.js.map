{"version":3,"sources":["../../../src/util/monad-t/state.js"],"names":["State","constructor","run","chain","f","s","result","fst","snd","evalState","exec","map","a","of","b","get","put","modify","no","StateT","M"],"mappings":";;;;;;;AAEA;;AAEA;;;;;;AAEO,MAAMA,KAAN,CAAkB;AAEvBC,cAAYC,GAAZ,EAAwC;AACtC,SAAKA,GAAL,GAAWA,GAAX;AACD;AACDC,QAAUC,CAAV,EAAmD;AACjD,WAAO,IAAIJ,KAAJ,CAAWK,CAAD,IAAwB;AACvC,UAAMC,SAAsB,KAAKJ,GAAL,CAASG,CAAT,CAA5B;AACA,aAAOD,EAAEE,OAAOC,GAAP,EAAF,EAAgBL,GAAhB,CAAoBI,OAAOE,GAAP,EAApB,CAAP;AACD,KAHM,CAAP;AAID;AACDC,YAAUJ,CAAV,EAAmB;AACjB,WAAO,KAAKH,GAAL,CAASG,CAAT,EAAYE,GAAZ,EAAP;AACD;AACDG,OAAKL,CAAL,EAAc;AACZ,WAAO,KAAKH,GAAL,CAASG,CAAT,EAAYG,GAAZ,EAAP;AACD;AACDG,MAAQP,CAAR,EAA2D;AACzD,WAAO,KAAKD,KAAL,CAAYS,CAAD,IAAwB,IAAIZ,KAAJ,CAAUI,EAAEQ,CAAF,CAAV,CAAnC,CAAP;AACD;AACD;AACA;AACA;;AAEA,SAAOC,EAAP,CAAmBD,CAAnB,EAAyC;AACvC,WAAO,IAAIZ,KAAJ,CAAUc,KAAK,oBAAUF,CAAV,EAAaE,CAAb,CAAf,CAAP;AACD;;AAED,SAAOC,GAAP,GAA8B;AAC5B,WAAO,IAAIf,KAAJ,CAAWK,CAAD,IAAO,oBAAUA,CAAV,EAAaA,CAAb,CAAjB,CAAP;AACD;;AAED;AACA;AACA;;AAEA,SAAOW,GAAP,CAAWX,CAAX,EAAc;AACZ,WAAOY,OAAOC,MAAMb,CAAb,CAAP;AACD;AAtCsB;;QAAZL,K,GAAAA,K,EAyCb;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASa,EAAT,CAAYD,CAAZ,EAAe;AACb,SAAO,IAAIZ,KAAJ,CAAUc,KAAK,oBAAUF,CAAV,EAAaE,CAAb,CAAf,CAAP;AACD;;AAED,IAAMC,MAAM,IAAIf,KAAJ,CAAWK,CAAD,IAAO,oBAAUA,CAAV,EAAaA,CAAb,CAAjB,CAAZ;;AAEA,SAASY,MAAT,CAAgBb,CAAhB,EAAmB;AACjB,SAAO,IAAIJ,KAAJ,CAAWK,CAAD,IAAO,oBAAU,IAAV,EAAgBD,EAAEC,CAAF,CAAhB,CAAjB,CAAP;AACD;;AAED,SAASW,GAAT,CAAaX,CAAb,EAAgB;AACd,SAAOY,OAAOC,MAAMb,CAAb,CAAP;AACD;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMc,SAAgBC,CAAP,IAAa,CAwD3B,CAxDD","file":"state.js","sourcesContent":["//@flow\n\nimport { ᐸMapᐳ, ᐸEmptyᐳ, λMap } from './index.h'\n\nimport Tuple from './tuple'\n\nexport class State<L, R> {\n  run: (r: R) => Tuple<L, R>\n  constructor(run: (r: R) => Tuple<L, R>) {\n    this.run = run\n  }\n  chain<Lʹ>(f: (l: L) => State<Lʹ, R>): State<Lʹ, R> {\n    return new State((s: R): Tuple<Lʹ, R> => {\n      const result: Tuple<L, R> = this.run(s)\n      return f(result.fst()).run(result.snd())\n    })\n  }\n  evalState(s: R): L {\n    return this.run(s).fst()\n  }\n  exec(s: R): R {\n    return this.run(s).snd()\n  }\n  map<Lʹ>(f: (l: L) => (r: R) => Tuple<Lʹ, R>): State<Lʹ, R> {\n    return this.chain((a: L): State<Lʹ, R> => new State(f(a)))\n  }\n  // ap(a: *) {\n  //   return this.chain((f) => a.map(f))\n  // }\n\n  static of<Lʹ, +Rʹ>(a: Lʹ): State<Lʹ, Rʹ> {\n    return new State(b => new Tuple(a, b))\n  }\n\n  static get<+T>(): State<T, T> {\n    return new State((s) => new Tuple(s, s))\n  }\n\n  // static modify<-I, O>(f: (x: I) => O): State<null, O> {\n  //   return new State((s: I): Tuple<null, O> => new Tuple(null, f(s)))\n  // }\n\n  static put(s) {\n    return modify(no => s)\n  }\n}\n\n// function ap<I, O, R, Name>(\n//   s: State<((x: I) => State<O, R>), R>,\n//   a: λMap<Name, I>\n// ) {\n//   return s.chain((f) => a.map(f))\n// }\n\nfunction of(a) {\n  return new State(b => new Tuple(a, b))\n}\n\nconst get = new State((s) => new Tuple(s, s))\n\nfunction modify(f) {\n  return new State((s) => new Tuple(null, f(s)))\n}\n\nfunction put(s) {\n  return modify(no => s)\n}\n\n\n// type Func<+M, T> = {\n//   of<-I>(x: I): M,\n//   map<-I, +O>(f: (x: I) => O, m: M): M,\n// }\n//\n// class StateT<M> {\n//\n// }\n//\n// // Transformer\nconst StateT = <Name>(M) => {\n  class StateTʹ {\n\n  }\n  // const StateT = daggy.tagged('run');\n  // StateT.lift = (m) => {\n  //     return StateT((b) => {\n  //         return m.map((c) => Tuple2(c, b));\n  //     });\n  // };\n  //\n  // // https://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html#g:1\n  // StateT.hoist = (f) => (m) => {\n  //     return StateT((s) => {\n  //         return f(m.evalState(s)).map((x) => Tuple2(x, s));\n  //     });\n  // };\n  //\n  // StateT.of = (a) => {\n  //     return StateT((b) => M.of(Tuple2(a, b)));\n  // };\n  //\n  // StateT.prototype.chain = function(f) {\n  //     return StateT((s) => {\n  //         const result = this.run(s);\n  //         return result.chain((t) => f(t._1).run(t._2));\n  //     });\n  // };\n  //\n  // StateT.get = StateT((s) => M.of(Tuple2(s, s)));\n  //\n  // StateT.modify = (f) => {\n  //     return StateT((s) => M.of(Tuple2(null, f(s))));\n  // };\n  //\n  // StateT.put = function(s) {\n  //     return StateT.modify(constant(s));\n  // };\n  //\n  // StateT.prototype.evalState = function(s) {\n  //     return this.run(s).map((t) => t._1);\n  // };\n  //\n  // StateT.prototype.exec = function(s) {\n  //     return this.run(s).map((t) => t._2);\n  // };\n  //\n  // StateT.prototype.map = function(f) {\n  //     return this.chain((a) => StateT.of(f(a)));\n  // };\n  //\n  // StateT.prototype.ap = function(a) {\n  //     return this.chain((f) => a.map(f));\n  // };\n  //\n  // return StateT;\n}\n"]}