{"version":3,"sources":["../../../src/util/monad-t/index.js"],"names":["KeyValue","maybeAp","futureEither","eitherToFuture","These","Identity","Just","TupleT","Tuple","MTuple","fn","val","chain","data","map","f","traverseMaybe","traverseReducer","acc","list","reduce","traverseMaybe3","a","b","c","result","futureEitherWrap","future","res","fold","FutureEither","constructor","value","promise","either","mapL","chainL","chainAsync","toPlainFuture","chainAsyncL","chainRej","x","rj","rs","bitap","FutureT","wrapped","wrapEither","EitherT","asFuture","toFuture","both","e1","e2","isLeft","isRight","unwrapMaybe","toLeft","logic","cond","MaybeT","isJust","pass","unsafeGet","fail","m1","m2","ERR","isNothing","ap","toEither","m","toEitherR","toFutureR","traverse","traverse3","Error"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\n\nimport { Right, Left, of, ofL, type Apropos } from 'apropos'\nimport { append } from 'ramda'\nimport { Fluture, of as resolve, reject, Future } from 'fluture'\n// import { Maybe, Just } from 'folktale/maybe'\n\nimport { Maybe } from 'apropos'\nconst { Just } = Maybe\n\nimport * as Identity from './identity'\n\nexport {\n  Identity\n}\n\n\nimport OnlyStatic from '../only-static'\nimport { TupleT, Tuple, MTuple } from './tuple'\n\nexport { TupleT, Tuple, MTuple }\nexport { KeyValue } from './key-value'\n\nexport function maybeAp<I, O>(fn: Maybe<((x: I) => O)>, val: Maybe<I>): Maybe<O> {\n  return val.chain(data => fn.map(f => f(data)))\n}\n\nexport const traverseMaybe = (() => {\n  function traverseMaybe<T>(list: Maybe<T>[]): Maybe<T[]> {\n    const initial: T[] = []\n    return list.reduce(traverseReducer, Just(initial))\n  }\n\n  function traverseReducer<T>(acc: Maybe<T[]>, val: Maybe<T>): Maybe<T[]> {\n    return maybeAp(val.map(append), acc)\n  }\n\n  return traverseMaybe\n})()\n\nfunction traverseMaybe3<A, B, C>(a: Maybe<A>, b: Maybe<B>, c: Maybe<C>): Maybe<[A, B, C]> {\n  //$off\n  const result: any = traverseMaybe([a, b, c])\n  const vector3: Maybe<[A, B, C]> = result\n  return vector3\n}\n\nfunction futureEitherWrap<L, R>(\n  future: Fluture<R, L>\n): Fluture<Apropos<L, R>, void> {\n  declare var foldMerge: FoldMerge<L, R>\n  const res = /*:: foldMerge(*/  future.fold(Left, Right)\n  /*:: )*/\n  return res\n}\n\ntype FoldMerge<L, R> = <LI, RI>(\n  fluture: Fluture<RI, LI>\n) => Fluture<Apropos<L, R>, void>\n\nexport class FutureEither<Reject, Resolve> {\n  value: Fluture<Apropos<Reject, Resolve>, *>\n  constructor(value: Fluture<Apropos<Reject, Resolve>, void>) {\n    this.value = value\n  }\n  promise(): Promise<Apropos<Reject, Resolve>> {\n    return this.value.promise()\n  }\n  map<RN>(fn: (x: Resolve) => RN): FutureEither<Reject, RN> {\n    return new FutureEither(this.value.map(either => either.map(fn)))\n  }\n  mapL<F>(fn: (err: Reject) => F): FutureEither<F, Resolve> {\n    return new FutureEither(this.value.map(either => either.mapL(fn)))\n  }\n  chain<LN, RN>(fn: (x: Resolve) => Apropos<LN, RN>): FutureEither<Reject | LN, RN> {\n    return new FutureEither(this.value.map(either => either.chain(fn)))\n  }\n  chainL<LN, RN>(fn: (err: Reject) => Apropos<LN, RN>): FutureEither<LN, Resolve | RN> {\n    return new FutureEither(this.value.map(either => either.chainL(fn)))\n  }\n  chainAsync<LN, RN>(\n    fn: (x: Resolve) => Fluture<RN, LN>\n  ): FutureEither<Reject | LN, RN> {\n    return futureEither(\n      this.toPlainFuture().chain(fn)\n    )\n  }\n  chainAsyncL<LN, RN>(\n    fn: (x: Reject) => Fluture<RN, LN>\n  ): FutureEither<LN, Resolve | RN> {\n    return futureEither(\n      this.toPlainFuture().chainRej(fn)\n    )\n  }\n  toPlainFuture(): Fluture<Resolve, Reject> {\n    return this.value\n      .chain(\n        (x: Apropos<Reject, Resolve>): Fluture<Resolve, Reject> =>\n          eitherToFuture(x))\n  }\n}\n\nexport function futureEither<L, R>(future: Fluture<R, L>): FutureEither<L, R> {\n  return new FutureEither(futureEitherWrap(future))\n}\n\nexport function eitherToFuture<L, R>(either: Apropos<L, R>): Fluture<R, L> {\n  return Future((rj, rs) => {\n    either.bitap(rj, rs)\n  })\n}\n\nexport class FutureT extends OnlyStatic {\n  static futureEither<L, R>(future: Fluture<R, L>): FutureEither<L, R> {\n    const wrapped = futureEitherWrap(future)\n    return new FutureEither(wrapped)\n  }\n  static wrapEither = futureEitherWrap\n}\n\nexport class EitherT extends OnlyStatic {\n  static toFuture = eitherToFuture\n  static futureEither<L, R>(either: Apropos<L, R>): FutureEither<L, R> {\n    const asFuture = EitherT.toFuture(either)\n    return FutureT.futureEither(asFuture)\n  }\n  //$off\n  static both<L1, R1, L2, R2>(e1: Apropos<L1, R1>, e2: Apropos<L2, R2>): Apropos<L1 | L2, [R1, R2]> {\n    if (e1.isLeft()) return e1\n    return e2.isRight()\n      //$off\n      ? Right([e1.value, e2.value])\n      : e2\n  }\n\n  static unwrapMaybe<L, LN, R>(toLeft: () => LN, either: Apropos<L, Maybe<R>>) {\n    return either\n      .logic({\n        cond: MaybeT.isJust,\n        pass: MaybeT.unsafeGet,\n        fail: toLeft,\n      })\n  }\n}\n\n\n\nexport class MaybeT extends OnlyStatic {\n  static traverse = traverseMaybe\n\n  static both<T1, T2>(m1: Maybe<T1>, m2: Maybe<T2>): Maybe<[T1, T2]> {\n    const pair: any[] = [m1, m2]\n    return traverseMaybe(pair)\n    /*::\n      .map(() => [unsafeGetMaybe(m1), unsafeGetMaybe(m2)])\n    */\n  }\n  static traverse3 = traverseMaybe3\n\n  static unsafeGet<T>(x: Maybe<T>): T {\n    return x.fold(\n      ERR.isNothing,\n      x => x\n    )\n  }\n\n  static ap<I, O>(fn: Maybe<((x: I) => O)>, val: Maybe<I>): Maybe<O> {\n    return val.chain(data => fn.map(f => f(data)))\n  }\n\n  static toEither<L, R>(toLeft: () => L, m: Maybe<R>): Apropos<L, R> {\n    return m.fold(\n      () => Left(toLeft()),\n      Right\n    )\n  }\n\n  static toEitherR<R>(m: Maybe<R>): Apropos<void, R> {\n    return MaybeT.toEither(() => void 0, m)\n  }\n\n  static toFuture<L, R>(toLeft: () => L, m: Maybe<R>): Fluture<R, L> {\n    return m.fold(\n      () => reject(toLeft()),\n      resolve\n    )\n  }\n\n  static fold<T>(toLeft: () => T, m: Maybe<T>): T {\n    return m.fold(toLeft, x => x)\n  }\n\n  static toFutureR<R>(m: Maybe<R>): Fluture<R, void> {\n    return MaybeT.toFuture(() => void 0, m)\n  }\n\n  static isJust<-T>(x: Maybe<T>): boolean {\n    return x.isJust()\n  }\n\n}\n\n\nexport { These } from './these'\nexport type { λThese } from './these'\n\n/*::\ntype UnsafeGetMaybe = <T>(x: Maybe<T>) => T\ndeclare var unsafeGetMaybe: UnsafeGetMaybe\n*/\n\nconst ERR = {\n  isNothing() { throw new Error(`UnsafeMaybeValue recieve nothing`) }\n}\n"]}