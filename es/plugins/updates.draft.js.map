{"version":3,"sources":["../../src/plugins/updates.draft.js"],"names":[],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"updates.draft.js","sourcesContent":["// // @flow\n\n// // eslint-disable-next-line\n// import Promise from 'bluebird'\n// import Logger from 'mtproto-logger'\n// const debug = Logger`updates`\n\n// import { setUpdatesProcessor } from '../service/networker'\n// import type { ApiManagerInstance } from '../service/api-manager/index.h'\n// import type { TLFabric } from '../tl'\n\n// type PtsUpdate = {|\n//   pts: number;\n//   pts_count: number;\n// |}\n\n// type SeqUpdate = {|\n//   updates: Array<{||}>;\n//   date: number;\n//   seq: number;\n// |}\n\n// type UpdatesState = {\n//   pendingPtsUpdates: Array<PtsUpdate>;\n//   pendingSeqUpdates: { [k: number]: SeqUpdate };\n//   syncLoading: boolean;\n//   syncPending: ?{\n//     timeout: number;\n//     ptsAwaiting?: boolean;\n//     seqAwaiting?: number;\n//   };\n//   pts: number;\n//   seq: number;\n//   date: number;\n// }\n\n// // const AppPeersManager = null\n// // const AppUsersManager = null\n// const AppChatsManager = null\n\n// const UpdatesManager = (api: ApiManagerInstance, { apiLayer, on }: TLFabric) => {\n//   const updatesState: UpdatesState = {\n//     pendingPtsUpdates: [],\n//     pendingSeqUpdates: {},\n//     syncPending      : null,\n//     syncLoading      : true,\n//     pts              : 0,\n//     seq              : 0,\n//     date             : 0\n//   }\n//   const channelStates: { [k: number]: UpdatesState } = {}\n\n//   let myID = 0\n//   getUserID().then(id => myID = id)\n\n//   function setState(state: $Shape<UpdatesState>) {\n//     Object.assign(updatesState, state)\n//   }\n\n//   async function getUserID() {\n//     const auth = await api.storage.get('user_auth')\n//     return auth.id || 0\n//   }\n\n//   function popPendingSeqUpdate() {\n//     const nextSeq = updatesState.seq + 1\n//     const pendingUpdatesData = updatesState.pendingSeqUpdates[nextSeq]\n//     if (!pendingUpdatesData) {\n//       return false\n//     }\n//     const updates = pendingUpdatesData.updates\n//     updates.forEach(saveUpdate)\n//     updatesState.seq = pendingUpdatesData.seq\n//     if (pendingUpdatesData.date && updatesState.date < pendingUpdatesData.date) {\n//       updatesState.date = pendingUpdatesData.date\n//     }\n//     delete updatesState.pendingSeqUpdates[nextSeq]\n\n//     if (!popPendingSeqUpdate() &&\n//       updatesState.syncPending &&\n//       updatesState.syncPending.seqAwaiting &&\n//       updatesState.seq >= updatesState.syncPending.seqAwaiting) {\n//       if (!updatesState.syncPending.ptsAwaiting) {\n//         clearTimeout(updatesState.syncPending.timeout)\n//         updatesState.syncPending = null\n//       } else {\n//         delete updatesState.syncPending.seqAwaiting\n//       }\n//     }\n\n//     return true\n//   }\n\n//   function popPendingPtsUpdate(channelID) {\n//     const curState: UpdatesState = channelID ? getChannelState(channelID) : updatesState\n//     if (!curState.pendingPtsUpdates.length) {\n//       return false\n//     }\n//     curState.pendingPtsUpdates.sort((a, b) => a.pts - b.pts)\n\n//     let curPts = curState.pts\n//     let goodPts = false\n//     let goodIndex = 0\n//     let update\n//     let i = 0\n//     for (const update of curState.pendingPtsUpdates) {\n//       curPts += update.pts_count\n//       if (curPts >= update.pts) {\n//         goodPts = update.pts\n//         goodIndex = i\n//       }\n//       i++\n//     }\n\n//     if (!goodPts) {\n//       return false\n//     }\n\n//     debug('pop pending pts updates')(goodPts, curState.pendingPtsUpdates.slice(0, goodIndex + 1))\n\n//     curState.pts = goodPts\n//     for (let i = 0; i <= goodIndex; i++) {\n//       update = curState.pendingPtsUpdates[i]\n//       saveUpdate(update)\n//     }\n//     curState.pendingPtsUpdates.splice(0, goodIndex + 1)\n\n//     if (!curState.pendingPtsUpdates.length && curState.syncPending) {\n//       if (!curState.syncPending.seqAwaiting) {\n//         clearTimeout(curState.syncPending.timeout)\n//         curState.syncPending = null\n//       } else {\n//         delete curState.syncPending.ptsAwaiting\n//       }\n//     }\n\n//     return true\n//   }\n\n//   function forceGetDifference() {\n//     if (!updatesState.syncLoading) {\n//       getDifference()\n//     }\n//   }\n\n//   function processUpdateMessage(updateMessage: *) {\n//     // return forceGetDifference()\n//     const processOpts = {\n//       date    : updateMessage.date,\n//       seq     : updateMessage.seq,\n//       seqStart: updateMessage.seq_start\n//     }\n\n//     switch (updateMessage._) {\n//       case 'updatesTooLong':\n//       case 'new_session_created':\n//         forceGetDifference()\n//         break\n\n//       case 'updateShort':\n//         processUpdate(updateMessage.update, processOpts)\n//         break\n\n//       case 'updateShortMessage':\n//       case 'updateShortChatMessage': {\n//         const isOut = updateMessage.flags & 2\n//         const fromID = updateMessage.from_id || (isOut ? myID : updateMessage.user_id)\n//         /* eslint-disable */\n//         const toID = updateMessage.chat_id\n//           ? -updateMessage.chat_id\n//           : isOut ? updateMessage.user_id : myID\n//         /* eslint-enable */\n\n//         api.emit('updateShortMessage', {\n//           processUpdate,\n//           processOpts,\n//           updateMessage,\n//           fromID,\n//           toID\n//         })\n//       }\n//         break\n\n//       case 'updatesCombined':\n//       case 'updates':\n//         api.emit('apiUpdate', updateMessage)\n//         updateMessage.updates.forEach(update => processUpdate(update, processOpts))\n//         break\n\n//       default:\n//         debug('Unknown update message')(updateMessage)\n//     }\n//   }\n\n//   async function getDifference() {\n//     if (!updatesState.syncLoading) {\n//       updatesState.syncLoading = true\n//       updatesState.pendingSeqUpdates = {}\n//       updatesState.pendingPtsUpdates = []\n//     }\n\n//     if (updatesState.syncPending) {\n//       clearTimeout(updatesState.syncPending.timeout)\n//       updatesState.syncPending = null\n//     }\n\n//     const differenceResult = await api('updates.getDifference', {\n//       pts : updatesState.pts,\n//       date: updatesState.date,\n//       qts : -1\n//     })\n//     if (differenceResult._ === 'updates.differenceEmpty') {\n//       debug('apply empty diff')(differenceResult.seq)\n//       updatesState.date = differenceResult.date\n//       updatesState.seq = differenceResult.seq\n//       updatesState.syncLoading = false\n//       api.emit('stateSynchronized')\n//       return false\n//     }\n\n//     api.emit('difference', differenceResult)\n\n//     // Should be first because of updateMessageID\n//     // console.log(dT(), 'applying', differenceResult.other_updates.length, 'other updates')\n\n//     // eslint-disable-next-line\n//     const channelsUpdates = []\n//     differenceResult.other_updates.forEach(update => {\n//       switch (update._) {\n//         case 'updateChannelTooLong':\n//         case 'updateNewChannelMessage':\n//         case 'updateEditChannelMessage':\n//           processUpdate(update)\n//           return\n//       }\n//       saveUpdate(update)\n//     })\n\n//     // console.log(dT(), 'applying', differenceResult.new_messages.length, 'new messages')\n//     const updateNewMessage = apiMessage => saveUpdate({\n//       _        : 'updateNewMessage',\n//       message  : apiMessage,\n//       pts      : updatesState.pts,\n//       pts_count: 0\n//     })\n//     differenceResult.new_messages.forEach(updateNewMessage)\n\n//     const { seq, pts, date } = differenceResult.intermediate_state || differenceResult.state\n//     setState({ seq, pts, date })\n\n//     // console.log(dT(), 'apply diff', updatesState.seq, updatesState.pts)\n\n//     if (differenceResult._ == 'updates.differenceSlice') {\n//       getDifference()\n//     } else {\n//       // console.log(dT(), 'finished get diff')\n//       api.emit('stateSynchronized')\n//       updatesState.syncLoading = false\n//     }\n//   }\n\n//   async function getChannelDifference(channelID: number) {\n//     const channelState: UpdatesState = getChannelState(channelID)\n//     if (!channelState.syncLoading) {\n//       channelState.syncLoading = true\n//       channelState.pendingPtsUpdates = []\n//     }\n//     if (channelState.syncPending) {\n//       clearTimeout(channelState.syncPending.timeout)\n//       channelState.syncPending = null\n//     }\n//     // console.log(dT(), 'Get channel diff', AppChatsManager.getChat(channelID), channelState.pts)\n//     const differenceResult = await api('updates.getChannelDifference', {\n//       //$Flow Issue\n//       channel: AppChatsManager.getChannelInput(channelID),\n//       pts    : channelState.pts,\n//       limit  : 30\n//     })\n//     // console.log(dT(), 'channel diff result', differenceResult)\n//     channelState.pts = differenceResult.pts\n\n//     if (differenceResult._ == 'updates.channelDifferenceEmpty') {\n//       debug('apply channel empty diff')(differenceResult)\n//       channelState.syncLoading = false\n//       api.emit('stateSynchronized')\n//       return false\n//     }\n\n//     if (differenceResult._ == 'updates.channelDifferenceTooLong') {\n//       debug('channel diff too long')(differenceResult)\n//       channelState.syncLoading = false\n//       delete channelStates[channelID]\n//       saveUpdate({ _: 'updateChannelReload', channel_id: channelID })\n//       return false\n//     }\n\n//     api.emit('difference', differenceResult)\n\n//     // Should be first because of updateMessageID\n//     debug('applying')(differenceResult.other_updates.length, 'channel other updates')\n//     differenceResult.other_updates.map(saveUpdate)\n\n//     debug('applying')(differenceResult.new_messages.length, 'channel new messages')\n//     const updateNewChannelMessage = apiMessage => saveUpdate({\n//       _        : 'updateNewChannelMessage',\n//       message  : apiMessage,\n//       pts      : channelState.pts,\n//       pts_count: 0\n//     })\n//     differenceResult.new_messages.forEach(updateNewChannelMessage)\n\n//     debug('apply channel diff')(channelState.pts)\n\n//     if (differenceResult._ == 'updates.channelDifference' &&\n//       !differenceResult.final) {\n//       getChannelDifference(channelID)\n//     } else {\n//       debug('finished channel get diff')()\n//       api.emit('stateSynchronized')\n//       channelState.syncLoading = false\n//     }\n//   }\n\n//   function addChannelState(channelID: number, pts: ?number) {\n//     if (!pts) {\n//       throw new Error(`Add channel state without pts ${channelID}`)\n//     }\n//     if (channelStates[channelID] === undefined) {\n//       channelStates[channelID] = {\n//         pts,\n//         seq              : 0,\n//         date             : 0,\n//         pendingSeqUpdates: {},\n//         pendingPtsUpdates: [],\n//         syncPending      : null,\n//         syncLoading      : false\n//       }\n//       return true\n//     }\n//     return false\n//   }\n\n//   function getChannelState(channelID: number, pts?: ?number): UpdatesState {\n//     if (channelStates[channelID] === undefined) {\n//       addChannelState(channelID, pts)\n//     }\n//     return channelStates[channelID]\n//   }\n\n//   function processUpdate(update, options = {}) {\n//     let channelID\n//     switch (update._) {\n//       case 'updateNewChannelMessage':\n//       case 'updateEditChannelMessage':\n//         channelID = update.message.to_id.channel_id || update.message.to_id.chat_id\n//         break\n//       case 'updateDeleteChannelMessages':\n//         channelID = update.channel_id\n//         break\n//       case 'updateChannelTooLong':\n//         channelID = update.channel_id\n//         if (channelStates[channelID] === undefined) {\n//           return false\n//         }\n//         break\n//     }\n\n//     const curState: UpdatesState = channelID ? getChannelState(channelID, update.pts) : updatesState\n\n//     // console.log(dT(), 'process', channelID, curState.pts, update)\n\n//     if (curState.syncLoading) {\n//       return false\n//     }\n\n//     if (update._ == 'updateChannelTooLong') {\n//       getChannelDifference(channelID || 0)\n//       return false\n//     }\n\n//     let popPts\n//     let popSeq\n\n//     if (update.pts) {\n//       const newPts = curState.pts + (update.pts_count || 0)\n//       if (newPts < update.pts) {\n//         // debug('Pts hole')(curState, update, channelID && AppChatsManager.getChat(channelID))\n//         const newPending = {\n//           timeout: setTimeout(() =>\n//             channelID\n//               ? getChannelDifference(channelID)\n//               : getDifference(), 5000),\n//         }\n//         curState.pendingPtsUpdates.push(update)\n//         if (!curState.syncPending) curState.syncPending = newPending\n//         curState.syncPending.ptsAwaiting = true\n//         return false\n//       }\n//       if (update.pts > curState.pts) {\n//         curState.pts = update.pts\n//         popPts = true\n//       }\n//       else if (update.pts_count) {\n//         // console.warn(dT(), 'Duplicate update', update)\n//         return false\n//       }\n//       if (channelID && options.date && updatesState.date < options.date) {\n//         updatesState.date = options.date\n//       }\n//     }\n//     else if (!channelID && options.seq > 0) {\n//       const seq = options.seq\n//       const seqStart = options.seqStart || seq\n\n//       if (seqStart != curState.seq + 1) {\n//         if (seqStart > curState.seq) {\n//           // debug('Seq hole')(curState, curState.syncPending && curState.syncPending.seqAwaiting)\n//           const updates = curState.pendingSeqUpdates\n//           const newPending = {\n//             timeout: setTimeout(() => getDifference(), 5000)\n//           }\n//           const newSeqUpdate = { seq, date: options.date, updates: [] }\n\n//           if (updates[seqStart] === undefined) updates[seqStart] = newSeqUpdate\n//           updates[seqStart].updates.push(update)\n\n//           if (!curState.syncPending) curState.syncPending = newPending\n//           if (!curState.syncPending.seqAwaiting ||\n//             curState.syncPending.seqAwaiting < seqStart) {\n//             curState.syncPending.seqAwaiting = seqStart\n//           }\n//           return false\n//         }\n//       }\n\n//       if (curState.seq != seq) {\n//         curState.seq = seq\n//         if (options.date && curState.date < options.date) {\n//           curState.date = options.date\n//         }\n//         popSeq = true\n//       }\n//     }\n\n//     saveUpdate(update)\n\n//     if (popPts) {\n//       popPendingPtsUpdate(channelID)\n//     }\n//     else if (popSeq) {\n//       popPendingSeqUpdate()\n//     }\n//   }\n\n//   function saveUpdate(update: *) {\n//     api.emit('apiUpdate', update)\n//   }\n\n//   async function attach() {\n//     on('seq', result =>\n//       console.log('seq', result._, result, [...apiLayer.seqSet]))\n//     const { seq, pts, date }: UpdatesState = await api('updates.getState', {})\n//     setUpdatesProcessor(processUpdateMessage)\n//     setState({ seq, pts, date })\n//     setTimeout(() => setState({ syncLoading: false }), 1000)\n//   }\n\n//   return {\n//     processUpdateMessage,\n//     addChannelState,\n//     attach\n//   }\n// }\n\n// export default UpdatesManager"]}