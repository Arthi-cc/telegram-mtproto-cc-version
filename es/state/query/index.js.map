{"version":3,"sources":["../../../src/state/query/index.js"],"names":["Maybe","MaybeT","getState","toCryptoKey","toDCNumber","KeyStorage","fromNullable","resolveRequest","uid","dc","outID","getClient","map","command","chain","maybeGetK","pair","snd","queryRequest","reqID","state","request","e","client","getHomeStatus","homeStatus","fold","x","keyQuery","selector","keyStorage","getMaybe","queryHomeDc","homeDc","queryAuthID","authID","queryAuthKey","auth","querySalt","salt","queryKeys","dcʹ","traverse3","queryAck","pendingAck"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\n\n// import { fromNullable, Maybe } from 'folktale/maybe'\n\nimport { Maybe } from 'apropos'\n\nimport { MaybeT } from 'Monad'\n\nimport { getState } from '../portal'\nimport {\n  type Client,\n} from '../index.h'\n\nimport {\n  type DCNumber,\n  type UID,\n  toCryptoKey,\n  toDCNumber,\n} from 'Newtype'\nimport { KeyStorage } from 'Util/key-storage'\n\nconst { fromNullable } = Maybe\n\nexport const resolveRequest = (\n  uid: string,\n  dc: DCNumber,\n  outID: string\n): Maybe<string> =>\n  getClient(uid)\n    .map(({ command }) => command)\n    .chain(command => command.maybeGetK(outID))\n    .map(pair => pair.snd())\n\nexport const queryRequest = (uid: string, dc: DCNumber, outID: string) =>\n  resolveRequest(uid, dc, outID)\n    .chain((reqID: $off) => getClient(uid).chain(state => state.request.maybeGetK(reqID)))\n    .map(pair => pair.snd())\n\nexport function getClient(uid: string): Maybe<Client> {\n  return fromNullable(getState)\n    .chain(e => fromNullable(e()))\n    .chain(e => fromNullable(e.client))\n    .chain(e => fromNullable(e[uid]))\n  // const { client } = getState()\n  // return fromNullable(client[uid])\n}\n\nexport const getHomeStatus = (uid: string) =>\n  getClient(uid)\n    .map(client => client.homeStatus)\n    .fold(() => false, x => x)\n\ntype KeySelector = (x: Client) => KeyStorage\n\nconst keyQuery =\n  (selector: KeySelector) =>\n    (uid: UID, dc: DCNumber) =>\n      getClient(uid)\n        .map(selector)\n        .chain(fromNullable)\n        .chain(keyStorage => keyStorage.getMaybe(dc))\n        /*:: .map(toCryptoKey) */\n\nexport const queryHomeDc =\n  (uid: UID) =>\n    getClient(uid)\n      .map(client => client.homeDc)\n      .chain(fromNullable)\n      /*:: .map(toDCNumber) */\n\nexport const queryAuthID = keyQuery(client => client.authID)\nexport const queryAuthKey = keyQuery(client => client.auth)\nexport const querySalt = keyQuery(client => client.salt)\n\nexport const queryKeys = (uid: UID, dc: DCNumber) =>\n  fromNullable(dc)\n    .chain((dcʹ) =>  MaybeT\n      .traverse3(\n        queryAuthKey(uid, dcʹ),\n        queryAuthID(uid, dcʹ),\n        querySalt(uid, dcʹ)\n      )\n      .map(([auth, authID, salt]) => ({\n        uid,\n        dc: dcʹ,\n        auth,\n        authID,\n        salt,\n      })))\n\n\nexport const queryAck = (uid: UID, dc: DCNumber) =>\n  getClient(uid)\n    .map(client => client.pendingAck[dc])\n    .chain(fromNullable)\n    .fold(() => [], x => x)\n"]}