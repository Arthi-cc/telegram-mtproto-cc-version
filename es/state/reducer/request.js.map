{"version":3,"sources":["../../../src/state/reducer/request.js"],"names":["Maybe","trimType","toUID","KeyValue","TupleT","RpcApiError","ApiRequest","handleApiResp","state","task","msgID","outID","body","command","request","maybeGetK","chain","getRequestTuple","map","x","bimap","removeMsgID","req","deferFinal","resolve","removeK","requestID","fold","stateK","tupleToState","handleError","error","handled","errorObj","code","message","reject","getRequestByID","reqID","snd","tuple","traverseMaybe","fst","resolveTask","flags","id","api","resolved","methodResult","requestWatch","action","type","tasks","payload","newState"],"mappings":"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","file":"request.js","sourcesContent":["//@flow\n\n/* eslint-disable object-shorthand */\n\n// import { Pure, liftF } from '@safareli/free'\n// import { of, Left, Right } from 'apropos'\n// import { Maybe } from 'folktale/maybe'\nimport { Maybe } from 'apropos'\n\nimport type {\n  Client,\n} from '../index.h'\nimport {\n  trimType,\n} from '../helpers'\nimport {\n  type UID,\n  toUID,\n} from 'Newtype'\nimport { KeyValue, TupleT } from 'Monad'\nimport { RpcApiError } from '../../error'\nimport ApiRequest from '../../service/main/request'\n// import Config from 'ConfigProvider'\n\nimport {\n  type MessageUnit,\n} from '../../task/index.h'\n\nfunction handleApiResp(\n  state: Client,\n  task: MessageUnit,\n  msgID: UID,\n  outID: UID\n): Client {\n  const { body } = task\n  if (__DEV__)\n    console.log(`\\n--- request done ---\\n`, task.body)\n  const { command, request } = state\n  return command\n    .maybeGetK(outID)\n    /*:: .map(tuple => tuple.bimap(toUID, toUID)) */\n    .chain(getRequestTuple(request))\n    .map(x => x.bimap(\n      removeMsgID(command, outID),\n      req => {\n        req.deferFinal.resolve(body)\n        return request\n          .removeK(req.requestID)\n      }\n    ))\n    .fold(\n      stateK(state),\n      tupleToState(state))\n}\n\nfunction handleError(\n  state: Client,\n  task: MessageUnit,\n  msgID: UID,\n  outID: UID\n): Client {\n  if (__DEV__)\n    console.log(`\\n--- request error ---\\n`, task.body)\n  if (task.error.handled) return state\n  const errorObj = new RpcApiError(task.error.code, task.error.message)\n  const { command, request } = state\n  return command\n    .maybeGetK(outID)\n    /*:: .map(tuple => tuple.bimap(toUID, toUID)) */\n    .chain(getRequestTuple(request))\n    .map(x => x.bimap(\n      removeMsgID(command, outID),\n      req => {\n        req.deferFinal.reject(errorObj)\n        return request\n          .removeK(req.requestID)\n      }\n    ))\n    .fold(\n      stateK(state),\n      tupleToState(state))\n}\n\nconst getRequestByID =\n  (request: KeyValue<UID, ApiRequest>) =>\n    (reqID: UID): Maybe<ApiRequest> =>\n      request\n        .maybeGetK(reqID)\n        .map(TupleT.snd)\n\nconst removeMsgID = (command, outID) => msgID =>\n  command\n    .removeK(msgID)\n    .removeK(outID)\n\nconst getRequestTuple =\n  request =>\n    tuple =>\n      TupleT.traverseMaybe(\n        tuple.map(getRequestByID(request))\n      )\n\nconst stateK = (state: Client) => () => state\n\nconst tupleToState = (state: Client) => tuple => ({\n  ...state,\n  command: tuple.fst(),\n  request: tuple.snd(),\n})\n\nfunction resolveTask(state: Client, task: MessageUnit): Client {\n  const { flags } = task\n  const msgID = /*:: toUID( */ task.id /*:: ) */\n  if (flags.api) {\n    if (!task.api || !task.api.resolved) {\n      if (__DEV__)\n        console.error(`Task not found!`, task)\n    }\n    if (flags.methodResult) {\n      const outID = /*:: toUID( */ task.methodResult.outID /*:: ) */\n      if (flags.error) {\n        return handleError(state, task, msgID, outID)\n      } else if (flags.body) {\n        return handleApiResp(state, task, msgID, outID)\n      }\n    }\n  }\n  return state\n}\n\nexport default function requestWatch(state: Client, action: any): Client {\n  switch (trimType(action.type)) {\n    case ('api/task done'): {\n      const tasks: MessageUnit[] = action.payload\n      let newState = state\n      for (const task of tasks) {\n        newState = resolveTask(newState, task)\n      }\n      return newState\n    }\n    default: return state\n  }\n}\n"]}