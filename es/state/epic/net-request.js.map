{"version":3,"sources":["../../../src/state/epic/net-request.js"],"names":["Stream","of","awaitPromises","encaseP","after","ofF","Logger","log","API","NET","NetMessage","NetworkerThread","ApiRequest","apiMessage","mtMessage","encryptApiBytes","Config","Serialization","send","jsonError","TTLCache","queryKeys","MaybeT","toUID","makeAuthRequest","getState","dispatch","makeApiBytes","uid","dc","message","thread","rest","keys","session","get","isJust","TypeError","String","auth","salt","authID","unsafeGet","bytes","ctx","startMaxLength","body","length","writer","serverSalt","sessionID","map","data","requestCache","requestID","sendCache","msg_id","onNewTask","action","thru","NEXT","stream","e","payload","client","progress","current","filter","tap","val","i","promise","encryption","msgKey","url","noResponseMsgs","request","byteLength","mtBytes","authKeyID","encryptedBytes","propsToResult","result","netRequest","SEND","dcID","dcMap","halt","fold","requestItself","chain","res","RECEIVE_RESPONSE","chainRej","err","NETWORK_ERROR"],"mappings":"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","file":"net-request.js","sourcesContent":["//@flow\n\nimport { Stream, of, awaitPromises } from 'most'\nimport { encaseP, after, of as ofF } from 'fluture'\n\nimport Logger from 'mtproto-logger'\nconst log = Logger`net-request`\n\nimport { API, NET } from 'Action'\nimport { NetMessage } from '../../service/networker/net-message'\nimport NetworkerThread from '../../service/networker'\nimport ApiRequest from '../../service/main/request'\nimport { apiMessage, mtMessage, encryptApiBytes } from '../../service/chain/encrypted-message'\nimport Config from 'ConfigProvider'\nimport { Serialization } from '../../tl'\nimport { send } from '../../http'\nimport jsonError from 'Util/json-error'\nimport TTLCache from 'Util/request-cache'\nimport {\n  queryKeys,\n} from '../query'\nimport { MaybeT } from 'Monad'\nimport { toUID, type UID } from 'Newtype'\nimport { makeAuthRequest } from '../../service/invoke'\nimport { getState, dispatch } from '../portal'\n\nfunction makeApiBytes({ uid, dc, message, thread, ...rest }) {\n  const keys = queryKeys(uid, dc)\n  if (__DEV__)\n    console.error('keys', keys)\n  const session = Config.session.get(uid, dc)\n  if (!MaybeT.isJust(keys))\n    throw new TypeError(`No session! ${String(keys)}`)\n  const { auth, salt, authID } = MaybeT.unsafeGet(keys)\n  if (__DEV__)\n    console.warn('salt, session', salt, session)\n  const bytes = apiMessage({\n    ctx       : new Serialization({ startMaxLength: message.body.length + 64 }, uid).writer,\n    serverSalt: salt,\n    sessionID : session,\n    message\n  })\n  return encryptApiBytes(bytes, auth)\n    .map(data => ({\n      ...rest,\n      ...data,\n      uid, dc, message, thread,\n      auth, salt, session, authID\n    }))\n}\n\nconst requestCache = TTLCache(\n  ({ requestID }: ApiRequest) => requestID,\n  80\n)\n\nconst sendCache = TTLCache(\n  data => data.message.msg_id,\n  80\n)\n\nexport const onNewTask = (action: Stream<any>) => action\n  .thru(API.NEXT.stream)\n  .map(e => e.payload)\n  .map(({ uid }) => getState().client[uid])\n  .map(e => e.progress.current[0])\n  .filter(e => !!e)\n  .filter(requestCache)\n  // .map(e => e.payload)\n  // .chain(e => of(e).delay(200))\n  // .delay(100)\n  // .thru(e => netStatusGuard(netStatuses.halt, homeStatus, e))\n  // .thru(guestStatus)\n  .tap(val => {\n    if (__DEV__)\n      console.warn('onNewTask', val)\n  })\n  .map(i => makeAuthRequest(i).promise())\n\n  // .tap(val => {\n  //   Array.isArray(val)\n  //     ? val.map(v => v.netReq.invoke())\n  //     : val.netReq.invoke()\n  // })\n  .filter(() => false)\n\nfunction encryption(ctx) {\n  const {\n    bytes,\n    msgKey,\n    authID,\n    uid,\n    url,\n    dc,\n    thread,\n    message,\n    noResponseMsgs,\n    ...rest\n  } = ctx\n  const request = new Serialization({\n    startMaxLength: bytes.byteLength + 256\n  }, uid).writer\n  const mtBytes = mtMessage({\n    ctx: request,\n    authKeyID: authID,\n    msgKey,\n    encryptedBytes: bytes\n  })\n\n  function propsToResult(result) {\n    return {\n      result,\n      message,\n      dc,\n      uid,\n      thread,\n      noResponseMsgs,\n    }\n  }\n\n  return send(url, mtBytes)\n    .map(propsToResult)\n}\n\nconst netRequest = (action: Stream<any>) => action\n  .thru(NET.SEND.stream)\n  .map(e => e.payload)\n  .map(data => ({ ...data, dc: data.thread.dcID }))\n  .map(data => ({ ...data, uid: data.thread.uid }))\n  .map(data => ({ ...data, url: Config.dcMap(data.uid, data.dc) }))\n  .filter(({ dc, uid }) => !Config.halt.get(uid, dc))\n  .filter(sendCache)\n  .filter(({ dc, uid }) => queryKeys(uid, dc).fold(() => false, () => true))\n  // .filter(({ message }) => getState()\n  //   .client[message.uid]\n  //   .lastMessages\n  //   .indexOf(message.msg_id) === -1)\n  .map(data => requestItself(data).promise())\n  .filter(() => false)\n  // .thru(awaitPromises)\n  // .tap(data => console.warn('RECIEVE RESP', data))\n  // .map(NET.RECEIVE_RESPONSE)\n  // .recoverWith(err => of(NET.NETWORK_ERROR(jsonError(err))))\n\nconst requestItself = data => after(100, data)\n  .chain(makeApiBytes)\n  .chain(encryption)\n  .map(res => dispatch(NET.RECEIVE_RESPONSE(res), data.uid))\n  .chainRej(err => ofF(dispatch(NET.NETWORK_ERROR(jsonError(err)), data.uid)))\n\nexport default netRequest\n"]}