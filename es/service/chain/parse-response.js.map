{"version":3,"sources":["../../../src/service/chain/parse-response.js"],"names":["Deserialization","bytesCmp","bytesToHex","convertToUint8Array","bytesToArrayBuffer","bytesFromArrayBuffer","CryptoWorker","getMsgKeyIv","readLong","readResponse","response","reader","authKeyStored","authKeyID","fetchIntBytes","Error","toString","msgKey","encryptedData","fetchRawBytes","byteLength","getOffset","authKey","aesKey","aesIv","dataWithPadding","aesDecrypt","getDataWithPad","readHash","currentSession","prevSession","uid","sessionID","messageID","typeBuffer","isInvalidSession","console","warn","seqNo","fetchInt","offset","totalLength","messageBodyLength","messageBody","buffer","paddingLength","hashData","subarray","dataHash","sha1Hash","slice","fetchObject","parsedResponse"],"mappings":"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","file":"parse-response.js","sourcesContent":["//@flow\n\nimport { Deserialization } from '../../tl'\nimport { bytesCmp, bytesToHex, convertToUint8Array, bytesToArrayBuffer, bytesFromArrayBuffer } from '../../bin'\nimport CryptoWorker from '../../crypto'\nimport getMsgKeyIv from './msg-key'\nimport { readLong } from '../../tl/reader'\n\ntype ReadResponse = {\n  response: ArrayBuffer | Buffer,\n  reader: Deserialization,\n  authKeyStored: number[]\n}\n\ntype GetDataWithPad = {\n  authKey: Uint8Array,\n  msgKey: Uint8Array,\n  encryptedData: Uint8Array\n}\n\ntype ReadHash = {\n  reader: Deserialization,\n  currentSession: number[],\n  prevSession: number[],\n  dataWithPadding: ArrayBuffer,\n  uid: string,\n}\n\ntype ParsedResponse = {\n  hashData: Uint8Array,\n  msgKey: Uint8Array,\n  reader: Deserialization,\n}\n\n\nexport function readResponse({ response, reader, authKeyStored }: ReadResponse) {\n  const authKeyID = reader.fetchIntBytes(64, 'auth_key_id')\n  if (!bytesCmp(authKeyID, authKeyStored)) { //TODO Remove auth keys from logs\n    throw new Error(\n      `[MT] Invalid server auth_key_id: ${authKeyID.toString()} ${bytesToHex(authKeyID)}, authKeyStored: ${authKeyStored.toString()} ${bytesToHex(authKeyStored)}`\n    )\n  }\n  const msgKey = reader.fetchIntBytes(128, 'msg_key')\n  const encryptedData = reader.fetchRawBytes(\n    response.byteLength - reader.getOffset(),\n    'encrypted_data')\n  return {\n    msgKey,\n    encryptedData\n  }\n}\n\n\nexport async function getDataWithPad({ authKey, msgKey, encryptedData }: GetDataWithPad) {\n  const [aesKey, aesIv] = await getMsgKeyIv(authKey, msgKey, false)\n  const dataWithPadding = await CryptoWorker.aesDecrypt(encryptedData, aesKey, aesIv)\n  return dataWithPadding\n}\n\nexport function readHash({ reader, currentSession, prevSession, dataWithPadding, uid }: ReadHash) {\n  reader.fetchIntBytes(64, 'salt')\n  const sessionID = reader.fetchIntBytes(64, 'session_id')\n  const messageID = readLong(reader.typeBuffer, 'message_id')\n\n  const isInvalidSession = !bytesCmp(sessionID, currentSession) && (!prevSession\n    //eslint-disable-next-line\n    || !bytesCmp(sessionID, prevSession));\n  if (isInvalidSession) {\n    console.warn('Invalid server session', sessionID, currentSession, prevSession)\n    // throw new Error(`[MT] Invalid server session_id: ${ bytesToHex(sessionID) } ${sessionID.toString()}  ${bytesToHex(currentSession)} ${currentSession.toString()}`)\n  }\n\n  const seqNo = reader.fetchInt('seq_no')\n\n  let offset = reader.getOffset()\n  const totalLength = dataWithPadding.byteLength\n\n  const messageBodyLength = reader.fetchInt('message_data[length]')\n  if (messageBodyLength % 4\n    || messageBodyLength > totalLength - offset) {\n    throw new Error(`[MT] Invalid body length: ${  messageBodyLength}`)\n  }\n  const messageBody = reader.fetchRawBytes(messageBodyLength, 'message_data')\n\n  const buffer = bytesToArrayBuffer(messageBody)\n\n  offset = reader.getOffset()\n  const paddingLength = totalLength - offset\n  if (paddingLength < 0 || paddingLength > 15)\n    throw new Error(`[MT] Invalid padding length: ${paddingLength}`)\n  const hashData =\n    convertToUint8Array(dataWithPadding)\n      .subarray(0, offset)\n\n  return {\n    hashData,\n    seqNo,\n    messageID,\n    sessionID,\n    buffer\n  }\n}\n\n\nexport async function parsedResponse({ hashData, msgKey, reader }: ParsedResponse) {\n  const dataHash = await CryptoWorker.sha1Hash(hashData)\n\n  if (!bytesCmp(msgKey, bytesFromArrayBuffer(dataHash).slice(-16))) {\n    console.warn(msgKey, bytesFromArrayBuffer(dataHash))\n    throw new Error('[MT] server msgKey mismatch')\n  }\n  const response = reader.fetchObject('', 'INPUT')\n\n  return response\n}\n"]}