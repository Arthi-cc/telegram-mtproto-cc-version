{"version":3,"sources":["../../src/tl/writer.js"],"names":["TypeWriter","longToInts","stringToChars","writeInt","ctx","i","field","writeBool","writeLongP","iHigh","iLow","writePair","writeLong","sLong","Array","isArray","length","writeIntBytes","str","toString","int1","int2","writeDouble","f","buffer","ArrayBuffer","intView","Int32Array","doubleView","Float64Array","writeBytes","bytes","list","binaryDataGuard","checkLength","next","set","addPadding","bits","console","warn","trace","Error","Uint8Array","byteLength","unescape","encodeURIComponent","undefined"],"mappings":"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","file":"writer.js","sourcesContent":["//@flow\n\nimport { TypeWriter } from './type-buffer'\nimport { longToInts, stringToChars } from '../bin'\n\n// import Logger from 'mtproto-logger'\n// const log = Logger`tl:writer`\n\nimport type { BinaryData } from './index.h'\n\n\nexport function writeInt(ctx: TypeWriter, i: number, field: string = '') {\n  ctx.writeInt(i, `${ field }:int`)\n}\n\nexport function writeBool(ctx: TypeWriter, i: boolean, field: string = '') {\n  if (i) {\n    ctx.writeInt(0x997275b5, `${ field }:bool`)\n  } else {\n    ctx.writeInt(0xbc799737, `${ field }:bool`)\n  }\n}\n\nexport function writeLongP(ctx: TypeWriter,\n                           iHigh: number,\n                           iLow: number,\n                           field: string) {\n  ctx.writePair(iLow, iHigh,\n                `${ field }:long[low]`,\n                `${ field }:long[high]`)\n}\n\nexport function writeLong(ctx: TypeWriter,\n                          sLong?: number[] | string | number,\n                          field: string = '') {\n  if (Array.isArray(sLong))\n    return sLong.length === 2\n        ? writeLongP(ctx, sLong[0], sLong[1], field)\n        : writeIntBytes(ctx, sLong, 64)\n  let str\n  if (typeof sLong !== 'string')\n    str = sLong\n        ? sLong.toString()\n        : '0'\n  else str = sLong\n  const [int1, int2] = longToInts(str)\n  ctx.writePair(int2, int1,\n                `${ field }:long[low]`,\n                `${ field }:long[high]`)\n}\n\nexport function writeDouble(ctx: TypeWriter,\n                            f: number,\n                            field: string = '') {\n  const buffer = new ArrayBuffer(8)\n  const intView = new Int32Array(buffer)\n  const doubleView = new Float64Array(buffer)\n\n  doubleView[0] = f\n\n  const [int1, int2] = intView\n  ctx.writePair(int2, int1,\n                `${ field }:double[low]`,\n                `${ field }:double[high]`)\n}\n\nexport function writeBytes(ctx: TypeWriter,\n                           bytes?: number[] | ArrayBuffer | string,\n                           /*field: string = ''*/) {\n  const { list, length } = binaryDataGuard(bytes)\n    // debug && console.log('>>>', bytesToHex(bytes), `${ field }:bytes`)\n\n  ctx.checkLength(length + 8)\n  if (length <= 253) {\n    ctx.next(length)\n  } else {\n    ctx.next(254)\n    ctx.next(length & 0xFF)\n    ctx.next((length & 0xFF00) >> 8)\n    ctx.next((length & 0xFF0000) >> 16)\n  }\n\n  ctx.set(list, length)\n  ctx.addPadding()\n}\n\nexport function writeIntBytes(ctx: TypeWriter,\n                              bytes: BinaryData  | ArrayBuffer | string,\n                              bits: number | false,\n                              /*field: string = ''*/) {\n  const { list, length } = binaryDataGuard(bytes)\n\n  if (bits) {\n    if (bits % 32 || length * 8 != bits) {\n      console.warn(bits)\n      console.trace()\n      throw new Error(`Invalid bits: ${  bits  }, ${length}`)\n    }\n  }\n  // debug && console.log('>>>', bytesToHex(bytes), `${ field }:int${  bits}`)\n  ctx.checkLength(length)\n  ctx.set(list, length)\n}\n\n\nconst binaryDataGuard = (bytes?: number[] | ArrayBuffer | Uint8Array | string) => {\n  let list, length\n  if (bytes instanceof ArrayBuffer) {\n    list = new Uint8Array(bytes)\n    length = bytes.byteLength\n  } else if (typeof bytes === 'string') {\n    list =\n      stringToChars(\n        unescape(\n          encodeURIComponent(\n            bytes)))\n    length = list.length\n  } else if (bytes === undefined) {\n    list = []\n    length = 0\n  } else {\n    list = bytes\n    length = bytes.length\n  }\n  return {\n    list,\n    length\n  }\n}"]}