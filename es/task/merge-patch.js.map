{"version":3,"sources":["../../src/task/merge-patch.js"],"names":["mergeWith","concat","append","groupBy","pipe","map","last","filter","fromPairs","contains","singleHandler","Logger","log","mergePatch","ctx","processed","message","summary","reduce","acc","msg","mergedSummary","mergeSummary","emptySummary","regrouped","regroupSummary","noAuth","dcWithoutAuth","auth","salt","session","omitSalt","updatedSalt","updatedSession","withNewSalt","normalized","processAck","ack","home","reqResend","resend","lastMessages","groupAndExtract","fn","dc","groupDcIds","e","id"],"mappings":"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","file":"merge-patch.js","sourcesContent":["//@flow\n// import { join } from 'path'\n// import { outputJsonSync } from 'fs-extra'\n\nimport { mergeWith, concat, append, groupBy, pipe, map, last, filter, fromPairs, contains } from 'ramda'\n\nimport {\n  type MessageUnit,\n\n  type ᐸPatchᐳSummary,\n  type ᐸPatchᐳMessage,\n  type ᐸPatchᐳAuthKey,\n  type ᐸPatchᐳSalt,\n  type ᐸPatchᐳSession,\n  type ᐸPatchᐳSummaryReduced,\n\n  type DcAuth\n} from './index.h'\n\nimport singleHandler from './single-handler'\n\nimport Logger from 'mtproto-logger'\nconst log = Logger`merge-patch`\n\n// const testID = String((Date.now() - ((Date.now() / 1e8) | 0) * 1e8) / 1e3 | 0)\n\n// let event = 0\n// const eventId = () => String( ++event )\n//\n// const LOG_PATH = [process.cwd(), 'logs', testID]\n\nexport default function mergePatch(ctx: *, processed: MessageUnit[]) {\n  const { message, summary } = processed\n    .reduce((acc, msg) => {\n      const { message, summary } = singleHandler(ctx, msg)\n      // const file = join(...LOG_PATH, eventId() + '.json')\n      // outputJsonSync(file, { message, summary }, { spaces: 2 })\n      return {\n        message: append(message, acc.message),\n        summary: append(summary, acc.summary),\n      }\n    }, { message: [], summary: [] })\n  const mergedSummary = summary.reduce(mergeSummary, emptySummary())\n  const regrouped = regroupSummary(mergedSummary)\n  const noAuth = dcWithoutAuth(regrouped.auth)\n  const { salt, session, ...omitSalt } = regrouped\n  const updatedSalt: { [dc: number]: number[] | false } = { ...salt, ...noAuth }\n  const updatedSession: { [dc: number]: ᐸPatchᐳSession | false } = { ...session, ...noAuth }\n  const withNewSalt: ᐸPatchᐳSummaryReduced = {\n    ...omitSalt,\n    salt   : updatedSalt,\n    session: updatedSession,\n  }\n  // const joinedAuth = joinDcAuth(withNewSalt)\n  // log`mergedSummary`(mergedSummary)\n  // log`regrouped`(withNewSalt)\n  // log`joinedAuth`(joinedAuth)\n  return {\n    normalized: message,\n    summary   : withNewSalt,\n  }\n}\n\n\nconst emptySummary = (): ᐸPatchᐳSummary => ({\n  processAck  : [],\n  ack         : [],\n  home        : [],\n  auth        : [],\n  reqResend   : [],\n  resend      : [],\n  lastMessages: [],\n  salt        : [],\n  session     : [],\n})\n\ntype MergeSummary = (acc: ᐸPatchᐳSummary, val: ᐸPatchᐳSummary) => ᐸPatchᐳSummary\n//$off\nconst mergeSummary: MergeSummary = mergeWith(concat)\n\n//$off\ntype GroupAndExtract/*:: <-T, S>*/ = (list: $ReadOnlyArray<T>) => { [dc: number]: S[] }\nconst groupAndExtract = /*:: <T, S>*/(fn: (x: T) => S): GroupAndExtract<T, S> => pipe(\n  groupBy(({ dc }: { dc: number }) => /*::(*/dc/*:: : $FlowIssue)*/),\n  map(map(fn))\n)\n\nconst groupDcIds: GroupAndExtract<ᐸPatchᐳMessage, string> = groupAndExtract(e => e.id)\n// const groupAuthKey: GroupAndExtract<ᐸPatchᐳAuthKey, number[] | false> = groupAndExtract(e => e.authKey)\n// const groupSalt: GroupAndExtract<ᐸPatchᐳSalt, number[]> = groupAndExtract(e => e.salt)\n// const groupSession: GroupAndExtract<ᐸPatchᐳSession, ᐸPatchᐳSession> = groupAndExtract(e => e)\n\nfunction regroupSummary(summary: ᐸPatchᐳSummary) {\n  const {\n    processAck,\n    ack,\n    // home,\n    // auth,\n    reqResend,\n    // resend,\n    // lastMessages,\n    // salt,\n    // session,\n  } = summary\n  const regrouped = {\n    ...summary,\n    processAck: groupDcIds(processAck),\n    ack       : groupDcIds(ack),\n    // home,\n    // auth        : reduceToLast(groupAuthKey(auth)),\n    reqResend : groupDcIds(reqResend),\n    // resend      : groupDcIds(resend),\n    // lastMessages: groupDcIds(lastMessages),\n    // salt        : reduceToLast(groupSalt(salt)),\n    // session     : reduceToLast(groupSession(session)),\n  }\n\n  return regrouped\n}\n\n\n// type ReduceToLast = <T>(dcMap: { [dc: number]: T[] }) => { [dc: number]: T }\n//$ off\n// const reduceToLast: ReduceToLast = map(last)\n\n//$off\ntype DcWithoutAuth = (auth: { [dc: number]: number[] | false }) =>\n  { [dc: number]: false }\nconst dcWithoutAuth: DcWithoutAuth = filter(e => e === false)\n\n\n// const empty: any = {}\n// const toDcs = obj => Object\n//   .keys(obj)\n//   .filter(isFinite)\n//   .map(e => parseInt(e, 10))\n//\n// function joinDcAuth(summary) {\n//   /*::\n//   type AuthMap = typeof summary.auth\n//   type SaltMap = typeof summary.salt\n//   type SessionMap = typeof summary.session\n//   */\n//   const emptyAuth: AuthMap = empty\n//   const emptySalt: SaltMap = empty\n//   const emptySession: SessionMap = empty\n//   const {\n//     auth = emptyAuth,\n//     salt = emptySalt,\n//     session = emptySession,\n//   } = summary\n//   const authKeys = toDcs(auth)\n//   const saltKeys = toDcs(salt)\n//   const sessionKeys = toDcs(session)\n//   const usedDcs = [...new Set([...authKeys, ...saltKeys, ...sessionKeys])]\n//   const emptyDcAuth: DcAuth = /*::(*/{}/*:: : any)*/\n//   let result: {\n//     //$ off\n//     [dc: number]: DcAuth\n//   } = fromPairs(usedDcs.map(e => [e, emptyDcAuth]))\n//   for (const dc of usedDcs) {\n//     let dcAuth = result[dc]\n//     const hasDc = contains(dc)\n//     if (hasDc(authKeys))\n//       dcAuth = { ...dcAuth, auth: auth[dc] }\n//     if (hasDc(saltKeys))\n//       dcAuth = { ...dcAuth, salt: salt[dc] }\n//     if (hasDc(sessionKeys))\n//       dcAuth = { ...dcAuth, session: session[dc] }\n//     result = { ...result, [dc]: dcAuth }\n//   }\n//   return result\n// }\n"]}