{"version":3,"sources":["../../src/task/processing.js"],"names":["initFlags","isApiObject","resolveRequest","MaybeT","processing","ctx","list","map","msg","processSingle","getIncoming","flags","body","type","container","contains","raw","inner","messageID","data","hasBody","insideInner","flagsResult","accResult","processInners","TypeError","omitRaw","_","processRpc","outID","req_msg_id","uid","dc","methodResult","api","rslt","result","maybeApiID","apiID","resolved","isJust","unsafeGet","error","code","error_code","message","error_message","handled","incoming","timestamp","Date","now"],"mappings":"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","file":"processing.js","sourcesContent":["//@flow\n\nimport {\n  type IncomingType,\n  type RawMessage,\n  type RawContainer,\n  type RawObject,\n  type ApiData,\n  type RawError,\n  type RawBody,\n  type RawInner,\n  type MessageDraft,\n  type SystemMessage,\n  type MessageUnit,\n} from './index.h'\nimport { initFlags, isApiObject } from './fixtures'\nimport { resolveRequest } from '../state/query'\nimport { MaybeT } from 'Monad'\n\n\nexport default function processing(ctx: IncomingType, list: MessageDraft[]) {\n  return list\n    .map(msg => processSingle(ctx, msg))\n}\n\n//$off\nfunction processSingle(ctx: IncomingType, msg: MessageDraft): MessageUnit {\n  let { flags, ...body } = getIncoming()\n  flags = initFlags(flags)\n  switch (msg.type) {\n    case 'container': {\n      flags = { ...flags, container: true }\n      const contains: string[] = msg.raw\n      body = { ...body, container: { contains } }\n      break\n    }\n    case 'inner': {\n      flags = { ...flags, inner: true }\n      body = { ...body, inner: { container: ctx.messageID } }\n      const data: RawInner = msg.raw\n      if (hasBody(data)) {\n        const insideInner = data.body\n        const { flagsResult, accResult } = processInners(ctx, msg, insideInner)\n        flags = { ...flags, ...flagsResult }\n        if (accResult != null)\n          body = { ...body, ...accResult }\n      }\n      break\n    }\n    case 'object': {\n      const data: RawObject = msg.raw\n      const { flagsResult, accResult } = processInners(ctx, msg, data)\n      flags = { ...flags, ...flagsResult }\n      if (accResult != null)\n        body = { ...body, ...accResult }\n      break\n    }\n    default: {\n      throw new TypeError(`Wrong draft type ${msg.type}`)\n    }\n  }\n  return { flags, ...body, ...omitRaw(msg) }\n}\n\nconst omitRaw = ({ raw, type, ...msg }) => msg\n\nfunction processInners(ctx: IncomingType, msg: MessageDraft, body) {\n  switch (body._) {\n    case 'rpc_result': {\n      //$FlowIssue\n      const rpcBody: RawBody = body\n      return processRpc(ctx, msg, rpcBody)\n    }\n    default: {\n      const accResult: {\n        +body: SystemMessage,\n      } = { body }\n      return {\n        flagsResult: { body: true },\n        accResult,\n      }\n    }\n  }\n}\n\nfunction processRpc(ctx: IncomingType, msg: MessageDraft, body: RawBody) {\n  const outID: string = body.req_msg_id\n  const { uid, dc } = ctx\n  let flagsResult = {\n    body        : false,\n    methodResult: true,\n    api         : true,\n  }\n  let accResult = {\n    methodResult: { outID },\n  }\n  const rslt = body.result\n  if (isApiObject(rslt)) {\n    flagsResult = {\n      ...flagsResult,\n      body: true,\n    }\n    const maybeApiID = resolveRequest(uid, dc, outID)\n    let apiID: string = '',\n        resolved = false\n    if (MaybeT.isJust(maybeApiID)) {\n      apiID = MaybeT.unsafeGet(maybeApiID)\n      resolved = true\n    }\n    accResult = {\n      ...accResult,\n      body: rslt,\n      api : {\n        resolved,\n        apiID,\n      },\n    }\n    if (rslt._ === 'rpc_error') {\n      flagsResult = {\n        ...flagsResult,\n        error: true,\n      }\n      accResult = {\n        ...accResult,\n        error: {\n          code   : rslt.error_code /*:: || 1 */,\n          message: rslt.error_message /*:: || '' */,\n          handled: false,\n        }\n      }\n    }\n  }\n  return {\n    flagsResult,\n    accResult,\n  }\n}\n\nfunction hasBody(msg: RawInner): boolean %checks {\n  return (\n    isApiObject(msg)\n    && isApiObject(msg.body)\n  )\n}\n\nconst getIncoming = () => ({\n  flags: {\n    incoming: true,\n  },\n  incoming: {\n    timestamp: Date.now()\n  }\n})\n"]}