{"version":3,"sources":["../../../src/util/monad-t/pro.js"],"names":["Left","Right","Tuple","Tagged","constructor","x","bimap","f","g","left","right","of"],"mappings":"AAEA,SAASA,IAAT,EAAeC,KAAf;;AAEA,OAAOC,KAAP,MAAkB,SAAlB;;AAEA,OAAO,MAAMC,MAAN,CAAkB;AAEvBC,cAAYC,CAAZ,EAAoB;AAClB,SAAKA,CAAL,CAAM,iBAAN,GAA0BA,CAA1B;AACD;AACDC,QAAiBC,CAAjB,EAAwBC,CAAxB,EAA2D;AACzD,WAAO,IAAIL,MAAJ,CAAWK,EAAE,KAAKH,CAAP,CAAX,CAAP;AACD;;AAEDI,SAAoC;AAClC,WAAO,IAAIN,MAAJ,CAAWH,KAAK,KAAKK,CAAV,CAAX,CAAP;AACD;;AAEDK,UAAqC;AACnC,WAAO,IAAIP,MAAJ,CAAWF,MAAM,KAAKI,CAAX,CAAX,CAAP;AACD;AACD,SAAOM,EAAP,CAAgBN,CAAhB,EAAuC;AACrC,WAAO,IAAIF,MAAJ,CAAWE,CAAX,CAAP;AACD;AAlBsB;;AAqBzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pro.js","sourcesContent":["//@flow\n\nimport { Left, Right, type Apropos } from 'apropos'\n\nimport Tuple from './tuple'\n\nexport class Tagged<Tag> {\n  +x: Tag\n  constructor(x: Tag) {\n    this.x/*:: ; const xx*/ = x\n  }\n  bimap<-F1, Tagʹ>(f: F1, g: (x: Tag) => Tagʹ): Tagged<Tagʹ> {\n    return new Tagged(g(this.x))\n  }\n\n  left(): Tagged<Apropos<Tag, mixed>> {\n    return new Tagged(Left(this.x))\n  }\n\n  right(): Tagged<Apropos<mixed, Tag>> {\n    return new Tagged(Right(this.x))\n  }\n  static of<Tagʹ>(x: Tagʹ): Tagged<Tagʹ> {\n    return new Tagged(x)\n  }\n}\n\n// \n// const dimapʹ = curry((f, g, x) => {\n//     return isFunction(x[dimap])\n//          ? x[dimap](f, g)\n//          : compose(g)(compose(x)(f))\n// })\n//\n// const lmapʹ = curry((f, x) => {\n//     return isFunction(x[lmap])\n//          ? x[lmap]()\n//          : isFunction(x[dimap])\n//            ? dimapʹ(f, identity, x)\n//            : compose(x)(f);\n// })\n//\n// const mapʹ = curry((f, x) => {\n//     return isFunction(x[map])\n//          ? x[map]()\n//          : isFunction(x[dimap])\n//            ? dimap(identity, f, x)\n//            : compose(f)(x)\n// })\n//\n// const arr = f => mapʹ(f, x => x)\n//\n// class Profunctor<I, O> {\n//   /*:: + */run: (x: I) => O\n//   constructor(run: (x: I) => O) {\n//     this.run/*:: ; const xx*/ = run\n//   }\n//   dimap(f, g) {\n//     return new Profunctor(dimapʹ(f, g, this.run))\n//   }\n//\n//   lmap<Iʹ>(f: (x: Iʹ) => I): Profunctor<Iʹ, O>\n//     return new Profunctor((x: Iʹ) => this.run(f(x)))\n//   }\n//\n//   map<Oʹ>(f: (x: O) => Oʹ): Profunctor<I, Oʹ> {\n//     return new Profunctor((x: I) => f(this.run(x)))\n//   }\n// }\n//\n// const Profunctor = tagged('run')\n//\n//\n//\n//\n// export type λStar<M> = {\n//   of<-T>(data: T): M,\n// }\n//\n// const Star = M => {\n//\n//     const Star = tagged('run');\n//\n//     Star.prototype[dimap] = function(f, g) {\n//         return Star(mapʹ(g, compose(this.run)(f)));\n//     };\n//\n//     Star.prototype[lmap] = function(f) {\n//         return Star(compose(this.run)(f));\n//     };\n//\n//     Star.prototype[map] = function(f) {\n//         return Star(mapʹ(f, this.run));\n//     };\n//\n//     Star.prototype.first = function() {\n//         return Star(x => this.run(x._1)[map](y => Tuple(y, x._2)));\n//     };\n//\n//     Star.prototype.second = function() {\n//         return Star(x => this.run(x._2)[map](y => Tuple(x._1, y)));\n//     };\n//\n//     Star.prototype.left = function() {\n//         return Star(x => x.fold(\n//             a => this.run(a)[map](Left),\n//             a => M[of](Right(a))\n//         ));\n//     };\n//\n//     Star.prototype.right = function() {\n//         return Star(x => x.fold(\n//             a => M[of](Left(a)),\n//             a => this.run(a)[map](Right)\n//         ));\n//     };\n//\n//     return Star;\n// };\n"]}