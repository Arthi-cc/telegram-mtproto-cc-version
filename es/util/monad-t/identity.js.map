{"version":3,"sources":["../../../src/util/monad-t/identity.js"],"names":["toString","equals","ᐸMapᐳ","ᐸChainᐳ","ᐸEmptyᐳ","ᐸChainRecᐳ","ᐸOfᐳ","λMap","λChain","ChainRecNext","constructor","value","isNext","done","of","ChainRecDone","Identity","map","f","chain","fn","get","is","empty","chainRec","typeID","MIdentity","i","state","ap","mapper","Object","assign"],"mappings":"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","file":"identity.js","sourcesContent":["//@flow\n\n/* eslint-disable no-whitespace-before-property */\n\nimport { toString, equals } from 'ramda'\n\nimport {\n  ᐸMapᐳ,\n  ᐸChainᐳ,\n  ᐸEmptyᐳ,\n  ᐸChainRecᐳ,\n  ᐸOfᐳ,\n  λMap,\n  λChain,\n} from './index.h'\n\nexport type ChainRec<T> = {\n  isNext: boolean,\n  value: T,\n}\n\nexport type CanBeMapped<V> = {\n  map<T>(fn: (x: V) => T): CanBeMapped<T>,\n}\n\ntype ChainRecF = <T>(x: T) => ChainRec<T>\n\ntype ChainRecIterator = <-I, O>(next: ChainRecF, done: ChainRecF, value: I) => ChainRec<O>\n\nclass ChainRecNext<T> {\n  isNext: boolean = true\n  done: boolean = false\n  value: T\n  constructor(value: T): ChainRec<T> {\n    this.value = value\n    /*:: return this */\n  }\n  static of<Tʹ>(value: Tʹ): ChainRec<Tʹ> {\n    return new ChainRecNext(value)\n  }\n}\n\nclass ChainRecDone<T> {\n  isNext: boolean = false\n  done: boolean = true\n  value: T\n  constructor(value: T): ChainRec<T> {\n    this.value = value\n    /*:: return this */\n  }\n  static of<Tʹ>(value: Tʹ): ChainRec<Tʹ> {\n    return new ChainRecDone(value)\n  }\n}\n\n/**\n * A data type that holds a value and exposes a monadic api.\n */\nexport\nclass Identity<T>\nimplements\n  λMap<'Identity', T>,\n  λChain<'Identity', T>\n{\n  typeName: 'Identity'\n  value: T\n  /**\n   * Constructs a new `Identity[a]` data type that holds a single\n   * value `a`.\n   * @param {*} a Value of any type\n   * @sig a -> Identity[a]\n   */\n  constructor(value: T) {\n    if (value instanceof ChainRecNext || value instanceof ChainRecDone)\n      this.value = value.value\n    else\n      this.value = value\n  }\n\n  /**\n   * Functor specification. Creates a new `Identity[a]` mapping function `f` onto\n   * `a` returning any value b.\n   * @param {Function} f Maps `a` to any value `b`\n   * @returns Identity[b]\n   * @sig @Identity[a] => (a -> b) -> Identity[b]\n   */\n  map<O>(f: (x: T) => O): Identity<O> {\n    return new Identity(f(this.value))\n  }\n\n  /**\n   * Chain specification. Transforms the value of the `Identity[a]`\n   * type using an unary function to monads. The `Identity[a]` type\n   * should contain a function, otherwise an error is thrown.\n   *\n   * @param {Function} fn Transforms `a` into a `Monad[b]`\n   * @returns Monad[b]\n   * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]\n   */\n  chain<Name, O>(fn: (x: T) => λChain<Name, O>): λChain<Name, O> {\n    return fn(this.value)\n  }\n\n  /**\n   * Returns the value of `Identity[a]`\n   *\n   * @returns a\n   * @sig (Identity[a]) => a\n   */\n  get(): T {\n    return this.value\n  }\n\n  equals(value: any): boolean {\n    if (value instanceof Identity)\n      return equals(this.value, value.value)\n    return equals(this.value, value)\n  }\n\n  toString() {\n    return `Identity(${  toString(this.value)  })`\n  }\n\n  static is = is\n\n  static of = of\n\n  static empty = empty\n\n  // static ap = ap\n\n  static chainRec = chainRec\n}\n\nconst typeID = 'zero-bias/Identity@1'\n\nexport const MIdentity: (\n  & ᐸMapᐳ<'Identity'>\n  & ᐸOfᐳ<'Identity'>\n  & ᐸEmptyᐳ<'Identity'>\n  & ᐸChainᐳ<'Identity'>\n  & ᐸChainRecᐳ<'Identity'>\n) = {\n  '@@type'               : typeID,\n  chainRec,\n  'fantasy-land/chainRec': chainRec,\n  of                     : <T>(value: T): Identity<T> => new Identity(value),\n  'fantasy-land/of'      : <T>(value: T): Identity<T> => new Identity(value),\n  empty                  : (): Identity<void> => new Identity(void 0),\n  'fantasy-land/empty'   : (): Identity<void> => new Identity(void 0),\n}\n\nexport function empty(): Identity<void> {\n  return new Identity(void 0)\n}\n\nexport function is(value: any): boolean {\n  return value instanceof Identity\n}\n\n/**\n * Applicative specification. Creates a new `Identity[a]` holding the value `a`.\n * @param {*} a Value of any type\n * @returns Identity[a]\n * @sig a -> Identity[a]\n */\nexport function of<Tʹ>(value: Tʹ): Identity<Tʹ> {\n  return new Identity(value)\n}\n\nexport function chainRec<Tʹ, N>(f: ChainRecIterator, i: Tʹ): Identity<N> {\n  let state = new ChainRecNext(i)\n  while (state.isNext) {\n    state = f(ChainRecNext.of, ChainRecDone.of, state.value)\n  }\n  declare var n: N\n  return new Identity((state.value /*:: , n */ ))\n}\n\n/**\n * Apply specification. Applies the function inside the `Identity[a]`\n * type to another applicative type.\n * @param {Applicative[a]} app Applicative that will apply its function\n * @returns Applicative[b]\n * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]\n */\n\nexport function ap<I, O>(mapper: Identity<((x: I) => O)>, value: CanBeMapped<I>): CanBeMapped<O> {\n  return value.map(mapper.value)\n}\n\n\n/*::  ; const dull = {} */\n\nObject.assign(/*:: dull, */ Identity, MIdentity)\n\n// //eslint-disable-next-line\n// Identity.prototype /*:: ; dull */ .ap =\n//   function(value: any) {\n//     return Identity.ap(this, value)\n//   }\n"]}