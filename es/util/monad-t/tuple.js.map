{"version":3,"sources":["../../../src/util/monad-t/tuple.js"],"names":["Maybe","ᐸMapᐳ","ᐸEmptyᐳ","λMap","OnlyStatic","Tuple","constructor","a","b","ᐸ1ᐳ","ᐸ2ᐳ","fst","snd","bimap","f","g","map","curry","uncurry","extend","extract","foldl","z","foldr","foldMap","equals","tuple","eqFirst","eqSecond","eq","toValue","toJSON","toString","String","of","TupleT","fromArray","list","key","val","ofTuple","traverseMaybe","bVal","canCompare","typeID","MTuple","empty","Object","assign","x"],"mappings":"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","file":"tuple.js","sourcesContent":["//@flow\n\n// import { Maybe } from 'folktale/maybe'\nimport { Maybe } from 'apropos'\n\nimport { ᐸMapᐳ, ᐸEmptyᐳ, λMap } from './index.h'\nimport OnlyStatic from '../only-static'\n\nexport class Tuple<+A, +B> implements λMap<'Tuple', B> {\n  typeName: 'Tuple'\n  +ᐸ1ᐳ: A\n  +ᐸ2ᐳ: B\n  constructor(a: *, b: *) {\n    this.ᐸ1ᐳ /*::; const aa */ = a\n    this.ᐸ2ᐳ /*::; const bb */ = b\n  }\n  fst(): A {\n    return this.ᐸ1ᐳ\n  }\n  snd(): B {\n    return this.ᐸ2ᐳ\n  }\n  bimap<Aʹ, Bʹ>(f: (a: A) => Aʹ, g: (b: B) => Bʹ): Tuple<Aʹ, Bʹ> {\n    return new Tuple(f(this.ᐸ1ᐳ), g(this.ᐸ2ᐳ))\n  }\n  map<Bʹ>(f: (b: B) => Bʹ): Tuple<A, Bʹ> {\n    return new Tuple(this.ᐸ1ᐳ, f(this.ᐸ2ᐳ))\n  }\n  curry<X>(f: (x: Tuple<A, B>) => X): X {\n    return f(this)\n  }\n  uncurry<X>(f: (a: A, b: B) => X): X {\n    return f(this.ᐸ1ᐳ, this.ᐸ2ᐳ)\n  }\n  extend<N>(f: (x: Tuple<A, B>) => N): Tuple<A, N> {\n    return new Tuple(this.ᐸ1ᐳ, f(this))\n  }\n  extract(): B {\n    return this.ᐸ2ᐳ\n  }\n  foldl<X, Z>(f: (b: B, z: Z) => X, z: Z): X {\n    return f(this.ᐸ2ᐳ, z)\n  }\n  foldr<X, Z>(f: (z: Z, b: B) => X, z: Z): X {\n    return f(z, this.ᐸ2ᐳ)\n  }\n  foldMap<X>(f: (b: B) => X): X {\n    return f(this.ᐸ2ᐳ)\n  }\n  equals<Aʹ, Bʹ>(tuple: Tuple<Aʹ, Bʹ>): boolean {\n    return this.eqFirst(tuple)\n      && this.eqSecond(tuple)\n  }\n  eqFirst<Aʹ, -Bʹ>(tuple: Tuple<Aʹ, Bʹ>): boolean {\n    return eq(this.fst(), tuple.fst())\n  }\n  eqSecond<-Aʹ, Bʹ>(tuple: Tuple<Aʹ, Bʹ>): boolean {\n    return eq(this.snd(), tuple.snd())\n  }\n  toValue() {\n    return [this.ᐸ1ᐳ, this.ᐸ2ᐳ]\n  }\n  toJSON() {\n    return this.toValue()\n  }\n  toString() {\n    return `Tuple( ${String(this.ᐸ1ᐳ)}, ${String(this.ᐸ2ᐳ)} )`\n  }\n  static of<Aʹ, Bʹ>(a: Aʹ, b: Bʹ): Tuple<Aʹ, Bʹ> {\n    return new Tuple(a, b)\n  }\n}\n\nexport class TupleT extends OnlyStatic {\n  static fromArray<A, B>(list: [A, B][]): Array<Tuple<A, B>> {\n    return list.map(([key, val]) => ofTuple(key, val))\n  }\n  static of = ofTuple\n  static traverseMaybe = traverseMaybe\n  static snd = snd\n  static fst = fst\n}\n\nfunction traverseMaybe<A, B>(tuple: Tuple<A, Maybe<B>>): Maybe<Tuple<A, B>> {\n  const a = tuple.fst()\n  const b = tuple.snd()\n  return b.map(bVal => new Tuple(a, bVal))\n}\n\nfunction snd<-A, B>(tuple: Tuple<A, B>): B {\n  return tuple.snd()\n}\n\nfunction fst<A, -B>(tuple: Tuple<A, B>): A {\n  return tuple.fst()\n}\n\nfunction eq(a, b): boolean {\n  if (a === b) return true\n  if (canCompare(a) && canCompare(b))\n    //$off\n    return a.equals(b) && b.equals(a)\n  return false\n}\n\nfunction ofTuple<Aʹ, Bʹ>(a: Aʹ, b: Bʹ): Tuple<Aʹ, Bʹ> {\n  return new Tuple(a, b)\n}\n\nconst typeID = 'zero-bias/Tuple@1'\n\nexport const MTuple: (\n  & ᐸMapᐳ<'Tuple'>\n  & ᐸEmptyᐳ<'Tuple'>\n) = {\n  '@@type'            : typeID,\n  of                  : <A, B>([a, b]: [A, B]): Tuple<A, B> => new Tuple(a, b),\n  'fantasy-land/of'   : <A, B>([a, b]: [A, B]): Tuple<A, B> => new Tuple(a, b),\n  empty               : (): Tuple<void, void> => new Tuple(void 0, void 0),\n  'fantasy-land/empty': (): Tuple<void, void> => new Tuple(void 0, void 0)\n}\n\n/*::  ; const dull = {} */\n\nObject.assign(/*:: dull, */ Tuple, MTuple)\n\nfunction canCompare(x): boolean {\n  return (\n    typeof x === 'object'\n    && x != null\n    && typeof x.equals === 'function'\n  )\n}\n\nexport default Tuple\n"]}