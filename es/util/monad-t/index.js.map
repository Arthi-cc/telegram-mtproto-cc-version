{"version":3,"sources":["../../../src/util/monad-t/index.js"],"names":["Right","Left","of","ofL","append","Fluture","resolve","reject","Future","Maybe","Just","Identity","OnlyStatic","TupleT","Tuple","MTuple","KeyValue","maybeAp","fn","val","chain","data","map","f","traverseMaybe","traverseReducer","acc","list","reduce","traverseMaybe3","a","b","c","result","futureEitherWrap","future","res","fold","FutureEither","constructor","value","promise","either","mapL","chainL","chainAsync","futureEither","toPlainFuture","chainAsyncL","chainRej","x","eitherToFuture","rj","rs","bitap","FutureT","wrapped","wrapEither","EitherT","asFuture","toFuture","both","e1","e2","isLeft","isRight","unwrapMaybe","toLeft","logic","cond","MaybeT","isJust","pass","unsafeGet","fail","m1","m2","ERR","isNothing","ap","toEither","m","toEitherR","toFutureR","traverse","traverse3","These","Error"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\n\nimport { Right, Left, of, ofL, type Apropos } from 'apropos'\nimport { append } from 'ramda'\nimport { Fluture, of as resolve, reject, Future } from 'fluture'\n// import { Maybe, Just } from 'folktale/maybe'\n\nimport { Maybe } from 'apropos'\nconst { Just } = Maybe\n\nimport * as Identity from './identity'\n\nexport {\n  Identity\n}\n\n\nimport OnlyStatic from '../only-static'\nimport { TupleT, Tuple, MTuple } from './tuple'\n\nexport { TupleT, Tuple, MTuple }\nexport { KeyValue } from './key-value'\n\nexport function maybeAp<I, O>(fn: Maybe<((x: I) => O)>, val: Maybe<I>): Maybe<O> {\n  return val.chain(data => fn.map(f => f(data)))\n}\n\nexport const traverseMaybe = (() => {\n  function traverseMaybe<T>(list: Maybe<T>[]): Maybe<T[]> {\n    const initial: T[] = []\n    return list.reduce(traverseReducer, Just(initial))\n  }\n\n  function traverseReducer<T>(acc: Maybe<T[]>, val: Maybe<T>): Maybe<T[]> {\n    return maybeAp(val.map(append), acc)\n  }\n\n  return traverseMaybe\n})()\n\nfunction traverseMaybe3<A, B, C>(a: Maybe<A>, b: Maybe<B>, c: Maybe<C>): Maybe<[A, B, C]> {\n  //$off\n  const result: any = traverseMaybe([a, b, c])\n  const vector3: Maybe<[A, B, C]> = result\n  return vector3\n}\n\nfunction futureEitherWrap<L, R>(\n  future: Fluture<R, L>\n): Fluture<Apropos<L, R>, void> {\n  declare var foldMerge: FoldMerge<L, R>\n  const res = /*:: foldMerge(*/  future.fold(Left, Right)\n  /*:: )*/\n  return res\n}\n\ntype FoldMerge<L, R> = <LI, RI>(\n  fluture: Fluture<RI, LI>\n) => Fluture<Apropos<L, R>, void>\n\nexport class FutureEither<Reject, Resolve> {\n  value: Fluture<Apropos<Reject, Resolve>, *>\n  constructor(value: Fluture<Apropos<Reject, Resolve>, void>) {\n    this.value = value\n  }\n  promise(): Promise<Apropos<Reject, Resolve>> {\n    return this.value.promise()\n  }\n  map<RN>(fn: (x: Resolve) => RN): FutureEither<Reject, RN> {\n    return new FutureEither(this.value.map(either => either.map(fn)))\n  }\n  mapL<F>(fn: (err: Reject) => F): FutureEither<F, Resolve> {\n    return new FutureEither(this.value.map(either => either.mapL(fn)))\n  }\n  chain<LN, RN>(fn: (x: Resolve) => Apropos<LN, RN>): FutureEither<Reject | LN, RN> {\n    return new FutureEither(this.value.map(either => either.chain(fn)))\n  }\n  chainL<LN, RN>(fn: (err: Reject) => Apropos<LN, RN>): FutureEither<LN, Resolve | RN> {\n    return new FutureEither(this.value.map(either => either.chainL(fn)))\n  }\n  chainAsync<LN, RN>(\n    fn: (x: Resolve) => Fluture<RN, LN>\n  ): FutureEither<Reject | LN, RN> {\n    return futureEither(\n      this.toPlainFuture().chain(fn)\n    )\n  }\n  chainAsyncL<LN, RN>(\n    fn: (x: Reject) => Fluture<RN, LN>\n  ): FutureEither<LN, Resolve | RN> {\n    return futureEither(\n      this.toPlainFuture().chainRej(fn)\n    )\n  }\n  toPlainFuture(): Fluture<Resolve, Reject> {\n    return this.value\n      .chain(\n        (x: Apropos<Reject, Resolve>): Fluture<Resolve, Reject> =>\n          eitherToFuture(x))\n  }\n}\n\nexport function futureEither<L, R>(future: Fluture<R, L>): FutureEither<L, R> {\n  return new FutureEither(futureEitherWrap(future))\n}\n\nexport function eitherToFuture<L, R>(either: Apropos<L, R>): Fluture<R, L> {\n  return Future((rj, rs) => {\n    either.bitap(rj, rs)\n  })\n}\n\nexport class FutureT extends OnlyStatic {\n  static futureEither<L, R>(future: Fluture<R, L>): FutureEither<L, R> {\n    const wrapped = futureEitherWrap(future)\n    return new FutureEither(wrapped)\n  }\n  static wrapEither = futureEitherWrap\n}\n\nexport class EitherT extends OnlyStatic {\n  static toFuture = eitherToFuture\n  static futureEither<L, R>(either: Apropos<L, R>): FutureEither<L, R> {\n    const asFuture = EitherT.toFuture(either)\n    return FutureT.futureEither(asFuture)\n  }\n  //$off\n  static both<L1, R1, L2, R2>(e1: Apropos<L1, R1>, e2: Apropos<L2, R2>): Apropos<L1 | L2, [R1, R2]> {\n    if (e1.isLeft()) return e1\n    return e2.isRight()\n      //$off\n      ? Right([e1.value, e2.value])\n      : e2\n  }\n\n  static unwrapMaybe<L, LN, R>(toLeft: () => LN, either: Apropos<L, Maybe<R>>) {\n    return either\n      .logic({\n        cond: MaybeT.isJust,\n        pass: MaybeT.unsafeGet,\n        fail: toLeft,\n      })\n  }\n}\n\n\n\nexport class MaybeT extends OnlyStatic {\n  static traverse = traverseMaybe\n\n  static both<T1, T2>(m1: Maybe<T1>, m2: Maybe<T2>): Maybe<[T1, T2]> {\n    const pair: any[] = [m1, m2]\n    return traverseMaybe(pair)\n    /*::\n      .map(() => [unsafeGetMaybe(m1), unsafeGetMaybe(m2)])\n    */\n  }\n  static traverse3 = traverseMaybe3\n\n  static unsafeGet<T>(x: Maybe<T>): T {\n    return x.fold(\n      ERR.isNothing,\n      x => x\n    )\n  }\n\n  static ap<I, O>(fn: Maybe<((x: I) => O)>, val: Maybe<I>): Maybe<O> {\n    return val.chain(data => fn.map(f => f(data)))\n  }\n\n  static toEither<L, R>(toLeft: () => L, m: Maybe<R>): Apropos<L, R> {\n    return m.fold(\n      () => Left(toLeft()),\n      Right\n    )\n  }\n\n  static toEitherR<R>(m: Maybe<R>): Apropos<void, R> {\n    return MaybeT.toEither(() => void 0, m)\n  }\n\n  static toFuture<L, R>(toLeft: () => L, m: Maybe<R>): Fluture<R, L> {\n    return m.fold(\n      () => reject(toLeft()),\n      resolve\n    )\n  }\n\n  static fold<T>(toLeft: () => T, m: Maybe<T>): T {\n    return m.fold(toLeft, x => x)\n  }\n\n  static toFutureR<R>(m: Maybe<R>): Fluture<R, void> {\n    return MaybeT.toFuture(() => void 0, m)\n  }\n\n  static isJust<-T>(x: Maybe<T>): boolean {\n    return x.isJust()\n  }\n\n}\n\n\nexport { These } from './these'\nexport type { λThese } from './these'\n\n/*::\ntype UnsafeGetMaybe = <T>(x: Maybe<T>) => T\ndeclare var unsafeGetMaybe: UnsafeGetMaybe\n*/\n\nconst ERR = {\n  isNothing() { throw new Error(`UnsafeMaybeValue recieve nothing`) }\n}\n"]}