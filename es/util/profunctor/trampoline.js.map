{"version":3,"sources":["../../../src/util/profunctor/trampoline.js"],"names":["cons","append","concatPair","Trampoline","run","x","applyStack","stack","fn","prepend","concat","snd","fst","empty","constructor","of","data","ln","length","current","val","i"],"mappings":"AAEA,SAASA,IAAT,EAAeC,MAAf,EAAuBC,UAAvB,QAAyC,WAAzC;;AAKA,eACA,MAAMC,UAAN,CAAuB;AAErBC,MAAIC,CAAJ,EAAa;AACX,WAAOC,WAAW,KAAKC,KAAhB,EAAuBF,CAAvB,CAAP;AACD;AACDJ,SAAWO,EAAX,EAAgD;AAC9C,WAAO,IAAIL,UAAJ,CAAeF,OAAOO,EAAP,EAAW,KAAKD,KAAhB,CAAf,CAAP;AACD;AACDE,UAAYD,EAAZ,EAAiD;AAC/C,WAAO,IAAIL,UAAJ,CAAeH,KAAKQ,EAAL,EAAS,KAAKD,KAAd,CAAf,CAAP;AACD;AACDG,SAAWC,GAAX,EAAsD;AACpD,WAAOR,WAAWO,MAAX,CAAkB,IAAlB,EAAwBC,GAAxB,CAAP;AACD;;AAED,SAAOD,MAAP,CACEE,GADF,EAEED,GAFF,EAGsB;AACpB,WAAO,IAAIR,UAAJ,CAAeD,WAAWU,IAAIL,KAAf,EAAsBI,IAAIJ,KAA1B,CAAf,CAAP;AACD;AACD,SAAOM,KAAP,GAA0C;AACxC,WAAO,IAAIV,UAAJ,CAAe,CAAEE,CAAD,IAAOA,CAAR,CAAf,CAAP;AACD;;AAEDS,cAAYP,KAAZ,EAAgC;AAAE,SAAKA,KAAL,GAAaA,KAAb;AAAoB;AACtD,SAAOQ,EAAP,CAAkBR,KAAlB,EAA4D;AAC1D,WAAO,IAAIJ,UAAJ,CAAeI,KAAf,CAAP;AACD;AA5BoB;;AAgCvB,OAAO,SAASD,UAAT,CAA0BC,KAA1B,EAA8CS,IAA9C,EAA0D;AAC/D,MAAMC,KAAKV,MAAMW,MAAjB;AACA,MAAID,OAAO,CAAX,EACE,OAAQD,IAAR;AACF,MAAIG,UAAUH,IAAd;AAAA,MAAoBR,WAApB;AAAA,MAAwBY,YAAxB;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIJ,EAApB,EAAwB,EAAEI,CAA1B,EAA6B;AAC3Bb,SAAKD,MAAMc,CAAN,CAAL;AACAD,UAAMZ,GAAGW,OAAH,CAAN;AACAA,cAAUC,GAAV;AACD;AACD,SAAQD,OAAR;AACD","file":"trampoline.js","sourcesContent":["//@flow\n\nimport { cons, append, concatPair } from './prelude'\n\nexport\ntype Stack<I, O> = Array<(val: any) => any>\n\nexport default\nclass Trampoline<I, O> {\n  stack: Stack<I, O>\n  run(x: I): O {\n    return applyStack(this.stack, x)\n  }\n  append<OB>(fn: (x: O) => OB): Trampoline<I, OB> {\n    return new Trampoline(append(fn, this.stack))\n  }\n  prepend<IB>(fn: (x: IB) => I): Trampoline<IB, O> {\n    return new Trampoline(cons(fn, this.stack))\n  }\n  concat<OB>(snd: Trampoline<O, OB>): Trampoline<I, OB> {\n    return Trampoline.concat(this, snd)\n  }\n\n  static concat<IA, OA, OB>(\n    fst: Trampoline<IA, OA>,\n    snd: Trampoline<OA, OB>,\n  ): Trampoline<IA, OB> {\n    return new Trampoline(concatPair(fst.stack, snd.stack))\n  }\n  static empty<Any>(): Trampoline<Any, Any> {\n    return new Trampoline([(x) => x])\n  }\n\n  constructor(stack: Stack<I, O>) { this.stack = stack }\n  static of<I1, O1>(stack: Stack<I1, O1>): Trampoline<I1, O1> {\n    return new Trampoline(stack)\n  }\n}\n\n\nexport function applyStack<I, O>(stack: Stack<I, O>, data: I): O {\n  const ln = stack.length\n  if (ln === 0)\n    return (data: $FlowIssue)\n  let current = data, fn, val\n  for (let i = 0; i < ln; ++i) {\n    fn = stack[i]\n    val = fn(current)\n    current = val\n  }\n  return (current: $FlowIssue)\n}\n"]}