{"version":3,"sources":["../../src/event/stream-bus.js"],"names":["Stream","Config","makeEventStream","MTProto","ApiRequest","NetworkerThread","NetMessage","MTError","RpcApiError","Logger","log","createStreamBus","ctx","emitter","rootEmitter","uid","bus","makeStreamMap","responseRaw","observe","messageIn","apiOnly","filter","value","isAPI","mtOnly","val","fastCache","get","dc","messages","set","msg_id","rpcError","untypedMessage","an","responseRawCast","newNetworkerCast","rpcResultCast","rpcErrorCast","untypedMessageCast","newRequestCast","messageInCast","newSessionCast","noAuthCast","getter","newNetworker","rpcResult","newRequest","newSession","noAuth"],"mappings":"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","file":"stream-bus.js","sourcesContent":["//@flow\n\nimport type { EventEmitterType } from 'eventemitter2'\nimport { Stream } from 'most'\n\nimport Config from 'ConfigProvider'\nimport { makeEventStream } from './make-event-stream'\n\nimport { MTProto } from '../service/main'\nimport ApiRequest from '../service/main/request'\nimport NetworkerThread from '../service/networker'\nimport { NetMessage } from '../service/networker/net-message'\nimport { MTError, RpcApiError } from '../error'\n\nimport Logger from 'mtproto-logger'\nconst log = Logger`stream-bus`\n\n\nconst createStreamBus = (ctx: MTProto) => {\n  const emitter = Config.rootEmitter(ctx.uid)\n  const bus = makeStreamMap(emitter)\n\n  bus.responseRaw.observe(log('raw response'))\n\n  bus.messageIn.observe(log('message in'))\n\n  const apiOnly = bus.messageIn.filter(value => value.isAPI)\n  const mtOnly = bus.messageIn.filter(value => !value.isAPI)\n\n  apiOnly.observe((val) => {\n    Config.fastCache.get(ctx.uid, val.dc).messages.set(val.msg_id, val)\n  })\n  mtOnly.observe((val) => {\n    Config.fastCache.get(ctx.uid, val.dc).messages.set(val.msg_id, val)\n  })\n\n  /* bus.rpcResult.observe(async(data: OnRpcResult) => {\n    log('rpc result')(data)\n    data.sentMessage.deferred.resolve(data.result)\n    ctx.state.messages.delete(data.sentMessage.msg_id)\n    const requestID = data.sentMessage.requestID\n    if (typeof requestID !== 'string') return\n    const req = ctx.state.requests.get(requestID)\n    if (req) {\n      // data.sentMessage.deferred.reject('No such request!')\n      req.defer.resolve(data.result)\n      ctx.state.requests.delete(requestID)\n    }\n  }) */\n\n  bus.rpcError.observe(log('rpc error'))\n\n  const isAuthRestart = (error: MTError) =>\n    error.code === 500\n    && error.type === 'AUTH_RESTART'\n\n  /* bus.rpcError.observe(async({ error, ...data }: OnRpcError) => {\n    if (error instanceof RpcApiError === false)\n      throw error\n    if (isFileMigrateError(error)) {\n      const newDc = getFileMigrateDc(error)\n      if (typeof newDc !== 'number') throw error\n      if (!ctx.state.messages.has(data.message.req_msg_id)) {\n        data.sentMessage.deferred.reject(error)\n        return log('on file migrate error')(data.message.req_msg_id, 'req_msg_id not found')\n      }\n      const msg = ctx.state.messages.get(data.message.req_msg_id)\n      if (!msg || !msg.requestID || typeof msg.requestID !== 'string') {\n        data.sentMessage.deferred.reject(error)\n        return log('on file migrate error')('msg', msg)\n      }\n      const req = ctx.state.requests.get(msg.requestID)\n      if (!req) {\n        data.sentMessage.deferred.reject(error)\n        return log('on file migrate error')('req', req)\n      }\n      req.options.dc = newDc\n      log('file migrate', 'req')(req)\n      log('on file migrate restart')('before end')\n      await ctx.api.invokeNetRequest(req)\n    } if (isMigrateError(error)) {\n      const newDc = getMigrateDc(error)\n      if (typeof newDc !== 'number') throw error\n      await ctx.storage.set('dc', newDc)\n      if (!ctx.state.messages.has(data.message.req_msg_id)) {\n        data.sentMessage.deferred.reject(error)\n        return log('on migrate error')(data.message.req_msg_id, 'req_msg_id not found')\n      }\n      const msg = ctx.state.messages.get(data.message.req_msg_id)\n      if (!msg || !msg.requestID || typeof msg.requestID !== 'string') {\n        data.sentMessage.deferred.reject(error)\n        return log('on migrate error')('msg', msg)\n      }\n      const req = ctx.state.requests.get(msg.requestID)\n      if (!req) {\n        data.sentMessage.deferred.reject(error)\n        return log('on migrate error')('req', req)\n      }\n      req.options.dc = newDc\n      log('migrate', 'req')(req)\n      log('on migrate restart')('before end')\n      await ctx.api.invokeNetRequest(req)\n    } else if (isAuthRestart(error)) {\n      if (!ctx.state.messages.has(data.message.req_msg_id)) {\n        data.sentMessage.deferred.reject(error)\n        return log('error', 'auth restart')(data.message.req_msg_id, 'req_msg_id not found')\n      }\n      const msg = ctx.state.messages.get(data.message.req_msg_id)\n      if (!msg || !msg.requestID) {\n        data.sentMessage.deferred.reject(error)\n        return log('error', 'auth restart')('no requestID msg', msg)\n      }\n      const req = ctx.state.requests.get(msg.requestID)\n      if (!req) {\n        data.sentMessage.deferred.reject(error)\n        return log('error', 'on auth restart')('no request info', msg)\n      }\n      const { authKey, saltKey } = dcStoreKeys(data.networkerDC)\n      log('on auth restart')(authKey, saltKey)\n      await ctx.storage.remove(authKey, saltKey)\n      log('on auth restart')('before end')\n      // await ctx.api.doAuth()\n      await ctx.api.invokeNetRequest(req)\n    } else if (error.code === 401) {\n\n      log('rpc', 'auth key unreg')(data.sentMessage)\n      const reqId = data.sentMessage.requestID\n      if (!reqId) {\n        data.sentMessage.deferred.reject(error)\n        return log('error', 'auth key unreg')('no requestID msg', data.sentMessage)\n      }\n      const dc = data.sentMessage.dc\n      const req = ctx.state.requests.get(reqId)\n      if (!req || !dc) {\n        data.sentMessage.deferred.reject(error)\n        return log('error', 'on auth key unreg')('no request info', dc, reqId)\n      }\n\n      // const { authKey, saltKey } = dcStoreKeys(dc)\n      // await ctx.storage.remove(authKey)\n      const thread = ctx.state.threads.get(data.threadID)\n      if (!thread) {\n        data.sentMessage.deferred.reject(error)\n        return log('error', 'on auth key unreg')('no thread', dc, data.threadID)\n      }\n      ctx.api.authBegin = false\n      log('on auth key unreg')('before end')\n      // const nearest = await ctx.storage.get('nearest_dc')\n\n      await ctx.storage.set('dc', currentDc)\n      // await new Promise(rs => setTimeout(rs, 1e3))\n      req.options.dc = currentDc\n      // await ctx.api.doAuth()\n      await ctx.api.invokeNetRequest(req)\n    } else {\n      log('rpc', 'unhandled')(data)\n      log('rpc', 'unhandled', 'error')(error)\n      // data.sentMessage.deferred.reject(error)\n    }\n  }) */\n\n  // bus.netMessage.observe((message) => {\n  //   log('net message')(message)\n  //   const req = ctx.state.messages.get(message.msg_id)\n  //   log('req')(req)\n  // })\n\n  // bus.netMessage.observe(log('new request'))\n\n  /* bus.newSession.observe(async({\n    threadID,\n    networkerDC,\n    message,\n    messageID\n  }) => {\n    const thread = ctx.state.threads.get(threadID)\n    if (!thread) {\n      log`new session, error, no thread`(threadID, messageID)\n      return\n    }\n    // await thread.applyServerSalt(message.server_salt)\n    // thread.ackMessage(messageID)\n    // thread.processMessageAck(message.first_msg_id)\n\n    log`new session, handled`(messageID, networkerDC)\n\n    const repeatRequest =\n      (req: ApiRequest) =>\n        of(req)\n          .map(ctx.api.invokeNetRequest)\n          .awaitPromises()\n\n    await from(ctx.state.requests.values())\n      // .debounce(30)\n      .map(repeatRequest)\n      .mergeConcurrently(1)\n      .observe(log`recurring requests`)\n  }) */\n\n  bus.untypedMessage.observe(log`untyped`)\n\n  // bus.noAuth.observe(async({\n  //   dc,\n  //   apiReq,\n  //   error\n  //   }: NoAuth) => {\n  //   // const mainDc  = await ctx.storage.get('dc')\n  //   // if (dc === mainDc) {\n\n  //   // } else {\n\n  //   // }\n  // })\n\n  return bus\n}\n\n\nconst an: any = {}\n\nconst responseRawCast    : RawEvent<Object> = an\nconst newNetworkerCast   : NetworkerThread = an\nconst rpcResultCast      : OnRpcResult = an\nconst rpcErrorCast       : OnRpcError = an\nconst untypedMessageCast : OnUntypedMessage = an\nconst newRequestCast     : ApiRequest = an\nconst messageInCast      : NetMessage = an\nconst newSessionCast     : OnNewSession = an\nconst noAuthCast         : NoAuth = an\n\nfunction makeStreamMap(emitter: EventEmitterType): Bus {\n  const getter = makeEventStream(emitter)\n\n  const responseRaw     = getter('response-raw', responseRawCast)\n  const newNetworker    = getter('new-networker', newNetworkerCast)\n  const rpcError        = getter('rpc-error', rpcErrorCast)\n  const rpcResult       = getter('rpc-result', rpcResultCast)\n  const untypedMessage  = getter('untyped-message', untypedMessageCast)\n  const newRequest      = getter('new-request', newRequestCast)\n  const messageIn       = getter('message-in', messageInCast)\n  const newSession      = getter('new-session', newSessionCast)\n  const noAuth          = getter('no-auth', noAuthCast)\n\n  const streamMap = {\n    responseRaw,\n    newNetworker,\n    rpcError,\n    untypedMessage,\n    newRequest,\n    messageIn,\n    rpcResult,\n    newSession,\n    noAuth,\n  }\n\n  return streamMap\n}\n\nexport type Bus = {\n  responseRaw: Stream<RawEvent<Object>>,\n  newNetworker: Stream<NetworkerThread>,\n  rpcResult: Stream<OnRpcResult>,\n  rpcError: Stream<OnRpcError>,\n  untypedMessage: Stream<OnUntypedMessage>,\n  newRequest: Stream<ApiRequest>,\n  messageIn: Stream<NetMessage>,\n  newSession: Stream<OnNewSession>,\n  noAuth: Stream<NoAuth>,\n}\n\ntype OnRpcResult = {\n  threadID: string,\n  networkerDC: number,\n  message: { _: string, req_msg_id: string, [key: string]: any },\n  sentMessage: NetMessage,\n  result: Object\n}\n\ntype OnRpcError = {\n  threadID: string,\n  networkerDC: number,\n  error: RpcApiError,\n  sentMessage: NetMessage,\n  message: { _: string, req_msg_id: string, [key: string]: any }\n}\n\ntype OnNewSession = {\n  threadID: string,\n  networkerDC: number,\n  message: {\n    _: string,\n    req_msg_id: string,\n    [key: string]: any\n  },\n  messageID: string\n}\n\ntype OnUntypedMessage = {\n  threadID: string,\n  networkerDC: number,\n  message: {\n    _: string,\n    req_msg_id: string,\n    [key: string]: any\n  },\n  messageID: string,\n  sessionID: Uint8Array,\n  result: Object,\n}\n\ntype RawEvent<T> = {\n  data: T,\n  status: number,\n  statusText: string\n}\n\ntype NoAuth = {\n  dc: number,\n  apiReq: ApiRequest,\n  error: MTError,\n}\n\n\n\n\nexport default createStreamBus\n"]}