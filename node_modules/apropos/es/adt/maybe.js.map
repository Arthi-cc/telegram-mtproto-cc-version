{"version":3,"sources":["../../src/adt/maybe.js"],"names":["Base","failSafeStringify","addInterop","MaybeBase","MaybeJust","constructor","value","ap","maybe","chain","fn","map","tap","fold","l","r","orElse","chainCond","cond","pass","MaybeNothing","logic","transformer","pred","check","match","Just","promise","Promise","resolve","equals","alt","both","and","isJust","isNothing","toString","x","Nothing","reject","Object","defineProperty","prototype","enumerable","writable","of","empty","validate","validators","reduce","acc","fromNullable"],"mappings":"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","file":"maybe.js","sourcesContent":["//@flow\n\nimport Base from '../base'\nimport { type Maybe } from '../index.h'\nimport { failSafeStringify, addInterop } from '../util'\n\ntype MaybeSign = 'just' | 'nothing'\n\nclass MaybeBase extends Base { isomer: MaybeSign }\n\nexport type { Maybe }\n\nclass MaybeJust<T> extends MaybeBase implements Maybe<T> {\n  value: T\n  constructor(value: T): Maybe<T> {\n    super()\n    this.value = value\n    /*:: return this */\n  }\n\n  ap<Tʹ>(maybe: Maybe<((x: T) => Tʹ)>): Maybe<Tʹ> {\n    return maybe.chain(fn => this.map(fn))\n  }\n\n  map<Tʹ>(fn: (x: T) => Tʹ): Maybe<Tʹ> {\n    return new MaybeJust(fn(this.value))\n  }\n\n  chain<Tʹ>(fn: (x: T) => Maybe<Tʹ>): Maybe<Tʹ> {\n    return fn(this.value)\n  }\n\n  tap(fn: (x: T) => any): Maybe<T> {\n    fn(this.value)\n    return this\n  }\n\n  fold<O>(l: () => O, r: (x: T) => O): O {\n    return r(this.value)\n  }\n\n  orElse(/*:: x: T */): T {\n    return this.value\n  }\n\n  chainCond<Tʹ>(\n    cond: (x: T) => boolean,\n    pass: (x: T) => Tʹ\n  ): Maybe<Tʹ> {\n    if (cond(this.value))\n      return new MaybeJust(pass(this.value))\n    declare var t: Tʹ\n    return new MaybeNothing(/*:: t */)\n  }\n\n  logic<Tʹ>(transformer: {\n    cond: (x: T) => boolean,\n    pass: (x: T) => Tʹ\n  }): Maybe<Tʹ> {\n    const { cond, pass } = transformer\n    return this.chainCond(cond, pass)\n  }\n\n  pred(check: (x: T) => boolean): Maybe<T> {\n    if (check(this.value))\n      return this\n    declare var t: T\n    return new MaybeNothing(/*:: t */)\n  }\n\n  match<J, N>(transformer: {\n    Just: (x: T) => J,\n    Nothing: () => N,\n  }): J | N {\n    const { Just } = transformer\n    return Just(this.value)\n  }\n\n  promise(): Promise<T> {\n    return Promise.resolve(this.value)\n  }\n\n  equals(value: any): boolean {\n    if (value instanceof MaybeJust) {\n      return this.value === value.value\n    }\n    return this.value === value\n  }\n\n  alt<S>(/*:: maybe: Maybe<S> */): Maybe<T | S> {\n    return /*:: addS( */ this /*:: ) */\n  }\n  both<S>(maybe: Maybe<S>): Maybe<[T, S]> {\n    if (maybe instanceof MaybeJust) {\n      return new MaybeJust([this.value, maybe.value])\n    }\n    declare var t: [T, S]\n    return new MaybeNothing(/*:: t */)\n  }\n  and<S>(maybe: Maybe<S>): Maybe<S> {\n    return maybe\n  }\n\n  isJust() {\n    return true\n  }\n  isNothing() {\n    return false\n  }\n\n  toString() {\n    return 'Just( ' + failSafeStringify(this.value) + ' )'\n  }\n}\n\nclass MaybeNothing<T> extends MaybeBase implements Maybe<T> {\n  constructor(/*:: value: T */): Maybe<T> {\n    super()\n    /*:: return this */\n  }\n\n  ap<Tʹ>(/*:: maybe: Maybe<((x: T) => Tʹ)> */): Maybe<Tʹ> {\n    return /*:: changeT( */ this /*:: ) */\n  }\n\n  map<Tʹ>(/*:: fn: (x: T) => Tʹ */): Maybe<Tʹ> {\n    return /*:: changeT( */ this /*:: ) */\n  }\n\n  chain<Tʹ>(/*:: fn: (x: T) => Maybe<Tʹ> */): Maybe<Tʹ> {\n    return /*:: changeT( */ this /*:: ) */\n  }\n\n  tap(/*:: fn: (x: T) => any */): Maybe<T> {\n    return this\n  }\n\n  fold<O>(l: () => O /*:: , r: (x: T) => O */): O {\n    return l()\n  }\n\n  orElse(x: T): T {\n    return x\n  }\n\n  chainCond<Tʹ>(/*::\n    cond: (x: T) => boolean,\n    pass: (x: T) => Tʹ\n  */): Maybe<Tʹ> {\n    declare var t: Tʹ\n    return new MaybeNothing(/*:: t */)\n  }\n\n  logic<Tʹ>(transformer: {\n    cond: (x: T) => boolean,\n    pass: (x: T) => Tʹ\n  }): Maybe<Tʹ> {\n    const { cond, pass } = transformer\n    return this.chainCond(cond, pass)\n  }\n\n  pred(/*:: check: (x: T) => boolean */): Maybe<T> {\n    return this\n  }\n\n  match<J, N>(transformer: {\n    Just: (x: T) => J,\n    Nothing: () => N,\n  }): J | N {\n    const { Nothing } = transformer\n    return Nothing()\n  }\n\n  promise(): Promise<T> {\n    return Promise.reject()\n  }\n\n  equals(value: any): boolean {\n    return value instanceof MaybeNothing\n  }\n\n  alt<S>(maybe: Maybe<S>): Maybe<T | S> {\n    return /*:: addS( */ maybe /*:: ) */\n  }\n  both<S>(/*:: maybe: Maybe<S> */): Maybe<[T, S]> {\n    declare var t: [T, S]\n    return new MaybeNothing(/*:: t */)\n  }\n  and<S>(/*:: maybe: Maybe<S> */): Maybe<S> {\n    declare var t: S\n    return new MaybeNothing(/*:: t */)\n  }\n\n  isJust() {\n    return false\n  }\n  isNothing() {\n    return true\n  }\n\n  toString() {\n    return 'Nothing()'\n  }\n}\n\nObject.defineProperty(MaybeJust.prototype, 'isomer', {\n  value     : 'just',\n  enumerable: true,\n  writable  : false,\n})\n\nObject.defineProperty(MaybeNothing.prototype, 'isomer', {\n  value     : 'nothing',\n  enumerable: true,\n  writable  : false,\n})\n\naddInterop(MaybeJust, 'Maybe')\naddInterop(MaybeNothing, 'Maybe')\n\nexport function Just<T>(value: T): Maybe<T> {\n  return new MaybeJust(value)\n}\n\nexport function of<T>(value: T): Maybe<T> {\n  return new MaybeJust(value)\n}\n\nexport function Nothing<+T>(): Maybe<T> {\n  declare var t: T\n  return new MaybeNothing(/*:: t */)\n}\n\nexport function empty<+T>(): Maybe<T> {\n  declare var t: T\n  return new MaybeNothing(/*:: t */)\n}\n\nexport function validate<T>(validators: $ReadOnlyArray<((x: T) => boolean)>) {\n  return (x: T): Maybe<T> => validators.reduce((acc, fn) => acc.pred(fn), new MaybeJust(x))\n}\n\nexport function fromNullable<T>(value: ?T): Maybe<T> {\n  declare var t: T\n  if (value == null) return new MaybeNothing(/*:: t */)\n  return new MaybeJust(value)\n}\n\ndeclare function toPair<T, +S>(maybe: Maybe<T>): Maybe<[T, S]>\ndeclare function addS<T, +S>(maybe: Maybe<T>): Maybe<T | S>\n\ndeclare function changeT<-T, +Tʹ>(maybe: Maybe<T>): Maybe<Tʹ>\n"]}