import Base from '../base';
import '../index.h';
import { failSafeStringify, addInterop } from '../util';

class MaybeBase extends Base {}

class MaybeJust extends MaybeBase {
  constructor(value) {
    super();
    this.value = value;
    /*:: return this */
  }

  ap(maybe) {
    return maybe.chain(fn => this.map(fn));
  }

  map(fn) {
    return new MaybeJust(fn(this.value));
  }

  chain(fn) {
    return fn(this.value);
  }

  tap(fn) {
    fn(this.value);
    return this;
  }

  fold(l, r) {
    return r(this.value);
  }

  orElse() {
    return this.value;
  }

  chainCond(cond, pass) {
    if (cond(this.value)) return new MaybeJust(pass(this.value));

    return new MaybeNothing();
  }

  logic(transformer) {
    var { cond, pass } = transformer;
    return this.chainCond(cond, pass);
  }

  pred(check) {
    if (check(this.value)) return this;

    return new MaybeNothing();
  }

  match(transformer) {
    var { Just } = transformer;
    return Just(this.value);
  }

  promise() {
    return Promise.resolve(this.value);
  }

  equals(value) {
    if (value instanceof MaybeJust) {
      return this.value === value.value;
    }
    return this.value === value;
  }

  alt() {
    return (/*:: addS( */this
    ); /*:: ) */
  }
  both(maybe) {
    if (maybe instanceof MaybeJust) {
      return new MaybeJust([this.value, maybe.value]);
    }

    return new MaybeNothing();
  }
  and(maybe) {
    return maybe;
  }

  isJust() {
    return true;
  }
  isNothing() {
    return false;
  }

  toString() {
    return 'Just( ' + failSafeStringify(this.value) + ' )';
  }
}

class MaybeNothing extends MaybeBase {
  constructor() {
    super();
    /*:: return this */
  }

  ap() {
    return (/*:: changeT( */this
    ); /*:: ) */
  }

  map() {
    return (/*:: changeT( */this
    ); /*:: ) */
  }

  chain() {
    return (/*:: changeT( */this
    ); /*:: ) */
  }

  tap() {
    return this;
  }

  fold(l /*:: , r: (x: T) => O */) {
    return l();
  }

  orElse(x) {
    return x;
  }

  chainCond() {
    return new MaybeNothing();
  }

  logic(transformer) {
    var { cond, pass } = transformer;
    return this.chainCond(cond, pass);
  }

  pred() {
    return this;
  }

  match(transformer) {
    var { Nothing } = transformer;
    return Nothing();
  }

  promise() {
    return Promise.reject();
  }

  equals(value) {
    return value instanceof MaybeNothing;
  }

  alt(maybe) {
    return (/*:: addS( */maybe
    ); /*:: ) */
  }
  both() {
    return new MaybeNothing();
  }
  and() {
    return new MaybeNothing();
  }

  isJust() {
    return false;
  }
  isNothing() {
    return true;
  }

  toString() {
    return 'Nothing()';
  }
}

Object.defineProperty(MaybeJust.prototype, 'isomer', {
  value: 'just',
  enumerable: true,
  writable: false
});

Object.defineProperty(MaybeNothing.prototype, 'isomer', {
  value: 'nothing',
  enumerable: true,
  writable: false
});

addInterop(MaybeJust, 'Maybe');
addInterop(MaybeNothing, 'Maybe');

export function Just(value) {
  return new MaybeJust(value);
}

export function of(value) {
  return new MaybeJust(value);
}

export function Nothing() {
  return new MaybeNothing();
}

export function empty() {
  return new MaybeNothing();
}

export function validate(validators) {
  return x => validators.reduce((acc, fn) => acc.pred(fn), new MaybeJust(x));
}

export function fromNullable(value) {
  if (value == null) return new MaybeNothing();
  return new MaybeJust(value);
}
//# sourceMappingURL=maybe.js.map