{"version":3,"sources":["../../src/adt/either.js"],"names":["Base","failSafeStringify","addInterop","Isomer","EitherRight","constructor","value","isRight","isLeft","orElse","promise","Promise","resolve","fold","l","r","swap","EitherLeft","equals","tap","fn","tapR","tapL","bitap","map","mapR","mapL","bimap","chain","chainR","chainL","bichain","cond","chainCond","pass","fail","logic","transformer","alt","or","and","e","thru","ap","toString","reject","Object","defineProperty","prototype","enumerable","writable","Right","Left","of","ofL","is"],"mappings":"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","file":"either.js","sourcesContent":["//@flow\n\nimport { type Either } from '../index.h'\nimport Base from '../base'\nimport { failSafeStringify, addInterop } from '../util'\n\nexport type { Either }\n\ntype IsomerSign = 'left' | 'right'\n\nclass Isomer extends Base { isomer: IsomerSign }\n\nclass EitherRight<L, R>\n  extends Isomer\n  implements Either<L, R> {\n  value: R\n  constructor(value: R): Either<L, R> {\n    super()\n    this.value = value\n    /*:: return this */\n  }\n  isRight(): boolean { return true }\n  isLeft(): boolean { return false }\n\n  orElse(/*::value: R*/): R {\n    return this.value\n  }\n\n  promise(): Promise<R> {\n    return Promise.resolve(this.value)\n  }\n\n  fold<O>(l: (x: L) => O, r: (x: R) => O): O {\n    return r(this.value)\n  }\n\n  swap(): Either<R, L> {\n    return new EitherLeft(this.value)\n  }\n\n  equals(value: any): boolean {\n    if (value instanceof Isomer) {\n      if (value instanceof EitherRight) {\n        return value.value === this.value\n      } else\n        return false\n    } else\n      return value === this.value\n  }\n\n\n\n  // --- Tap section ---\n\n  tap(fn: (x: R) => any): Either<L, R> {\n    return this.tapR(fn)\n  }\n  tapR(fn: (x: R) => any): Either<L, R> {\n    fn(this.value)\n    return this\n  }\n  tapL(/*:: fn: (x: L) => any */): Either<L, R> {\n    return this\n  }\n  bitap(l: (x: L) => any, r: (x: R) => any): Either<L, R> {\n    return this.tapR(r)\n  }\n\n\n\n  // --- Map section ---\n\n  map<R1>(fn: (x: R) => R1): Either<L, R1> {\n    return this.mapR(fn)\n  }\n  mapR<R1>(fn: (x: R) => R1): Either<L, R1> {\n    return new EitherRight(fn(this.value))\n  }\n  mapL<L1>(/*:: fn: (x: L) => L1 */): Either<L1, R> {\n    return /*:: changeL( */this /*::) */\n  }\n  bimap<L1, R1>(l: (x: L) => L1, r: (x: R) => R1): Either<L1, R1> {\n    return /*:: changeL( */this.mapR(r) /*::) */\n  }\n\n\n\n  // --- Chain section ---\n\n  chain<L1, R1>(fn: (x: R) => Either<L1, R1>): Either<L | L1, R1> {\n    return this.chainR(fn)\n  }\n  chainR<L1, R1>(fn: (x: R) => Either<L1, R1>): Either<L | L1, R1> {\n    return /*:: concatL(*/fn(this.value)/*::) */\n  }\n  chainL<L1, R1>(/*:: fn: (x: L) => Either<L1, R1> */): Either<L1, R | R1> {\n    return /*:: changeL(concatR(*/this/*::)) */\n  }\n  bichain<L1, L2, R1, R2>(\n    l: (x: L) => Either<L2, R2>,\n    r: (x: R) => Either<L1, R1>\n  ): Either<L1 | L2, R1 | R2> {\n    return /*:: concatR(concatL(*/r(this.value)/*::)) */\n  }\n\n\n\n  // --- Cond section ---\n\n  cond(fn: (x: R) => boolean): boolean {\n    return fn(this.value)\n  }\n\n  chainCond<L1, R1>(\n    cond: (x: R) => boolean,\n    pass: (x: R) => R1,\n    fail: (x: R) => L1\n  ): Either<L | L1, R1> {\n    if (this.cond(cond))\n      return /*:: concatL( */this.mapR(pass) /*::) */\n    else\n      return /*:: changeR( */new EitherLeft(fail(this.value))/*::) */\n  }\n\n  logic<L1, R1>(transformer: {\n    cond: (x: R) => boolean,\n    pass: (x: R) => R1,\n    fail: (x: R) => L1\n  }): Either<L | L1, R1> {\n    const { cond, pass, fail } = transformer\n    return this.chainCond(cond, pass, fail)\n  }\n\n\n\n  // --- Combine section ---\n\n  alt<L1, R1>(/*::e: Either<L1, R1>*/): Either<L1, R | R1> {\n    return /*:: concatR(changeL( */this /*::)) */\n  }\n\n  or<L1, R1>(/*::e: Either<L1, R1>*/): Either<L1, R | R1> {\n    return /*:: concatR(changeL( */this /*::)) */\n  }\n\n  and<L1, R1>(e: Either<L1, R1>): Either<L | L1, R1> {\n    return /*:: concatL(*/e/*::) */\n  }\n\n  thru<L1, R1>(fn: (x: Either<L, R>) => Either<L1, R1>): Either<L1, R1> {\n    return fn(this)\n  }\n\n  ap<L1, R1>(e: Either<L1, ((x: R) => R1)>): Either<L | L1, R1> {\n    if (e.isRight())\n      return /*:: concatL(*/e/*::) */.mapR(fn => fn(this.value))\n    return /*:: changeR(concatL( */e /*::)) */\n  }\n\n\n  toString() {\n    return 'Right( ' + failSafeStringify(this.value) + ' )'\n  }\n}\n\nclass EitherLeft<L, R>\n  extends Isomer\n  implements Either<L, R> {\n  value: L\n  constructor(value: L): Either<L, R> {\n    super()\n    this.value = value\n    /*:: return this */\n  }\n  isRight(): boolean { return false }\n  isLeft(): boolean { return true }\n\n  orElse(value: R): R {\n    return value\n  }\n\n  promise(): Promise<R> {\n    return Promise.reject(this.value)\n  }\n\n  fold<O>(l: (x: L) => O/*::, r: (x: R) => O*/): O {\n    return l(this.value)\n  }\n\n  swap(): Either<R, L> {\n    return new EitherRight(this.value)\n  }\n\n  equals(value: any): boolean {\n    if (value instanceof Isomer) {\n      if (value instanceof EitherLeft) {\n        return value.value === this.value\n      } else\n        return false\n    } else\n      return value === this.value\n  }\n\n\n\n  // --- Tap section ---\n\n  tap(fn: (x: R) => any): Either<L, R> {\n    return this.tapR(fn)\n  }\n  tapR(/*:: fn: (x: R) => any*/): Either<L, R> {\n    return this\n  }\n  tapL(fn: (x: L) => any): Either<L, R> {\n    fn(this.value)\n    return this\n  }\n  bitap(l: (x: L) => any, /*::r: (x: R) => any*/): Either<L, R> {\n    return this.tapL(l)\n  }\n\n\n\n  // --- Map section ---\n\n  map<R1>(/*:: fn: (x: R) => R1*/): Either<L, R1> {\n    return /*:: changeR( */this /*::) */\n  }\n  mapR<R1>(/*:: fn: (x: R) => R1*/): Either<L, R1> {\n    return /*:: changeR( */this /*::) */\n  }\n  mapL<L1>(fn: (x: L) => L1): Either<L1, R> {\n    return new EitherLeft(fn(this.value))\n  }\n  bimap<L1, R1>(l: (x: L) => L1/*::, r: (x: R) => R1*/): Either<L1, R1> {\n    return /*:: changeR( */this.mapL(l) /*::) */\n  }\n\n\n\n  // --- Chain section ---\n\n  chain<L1, R1>(fn: (x: R) => Either<L1, R1>): Either<L | L1, R1> {\n    return this.chainR(fn)\n  }\n  chainR<L1, R1>(/*:: fn: (x: R) => Either<L1, R1>*/): Either<L | L1, R1> {\n    return /*:: changeR(concatL(*/this/*::)) */\n  }\n  chainL<L1, R1>(fn: (x: L) => Either<L1, R1>): Either<L1, R | R1> {\n    return /*:: concatR(*/fn(this.value)/*::) */\n  }\n  bichain<L1, L2, R1, R2>(\n    l: (x: L) => Either<L2, R2>\n    /*::, r: (x: R) => Either<L1, R1>*/\n  ): Either<L1 | L2, R1 | R2> {\n    return /*:: concatR(concatL(*/l(this.value)/*::)) */\n  }\n\n\n\n  // --- Cond section ---\n\n  cond(/*:: fn: (x: R) => boolean*/): boolean {\n    return false\n  }\n\n  chainCond<L1, R1>(/*::\n    cond: (x: R) => boolean,\n    pass: (x: R) => R1,\n    fail: (x: R) => L1*/\n  ): Either<L | L1, R1> {\n    return /*:: changeR(concatL(*/this/*::)) */\n  }\n\n  logic<L1, R1>(/*::transformer: {\n    cond: (x: R) => boolean,\n    pass: (x: R) => R1,\n    fail: (x: R) => L1\n  }*/): Either<L | L1, R1> {\n    return /*:: changeR(concatL(*/this/*::)) */\n  }\n\n\n\n  // --- Combine section ---\n\n  alt<L1, R1>(e: Either<L1, R1>): Either<L1, R | R1> {\n    return  /*:: concatR(*/e/*::) */\n  }\n\n  or<L1, R1>(e: Either<L1, R1>): Either<L1, R | R1> {\n    return this.alt(e)\n  }\n\n  and<L1, R1>(/*:: e: Either<L1, R1>*/): Either<L | L1, R1> {\n    return /*:: changeR(concatL( */this /*::)) */\n  }\n\n  thru<L1, R1>(fn: (x: Either<L, R>) => Either<L1, R1>): Either<L1, R1> {\n    return fn(this)\n  }\n\n  ap<L1, R1>(/*:: e: Either<L1, ((x: R) => R1)>*/): Either<L | L1, R1> {\n    return /*:: changeR(concatL( */this /*::)) */\n  }\n\n\n\n  toString() {\n    return 'Left( ' + failSafeStringify(this.value) + ' )'\n  }\n}\naddInterop(EitherRight, 'Either')\naddInterop(EitherLeft, 'Either')\nObject.defineProperty(EitherRight.prototype, 'isomer', {\n  value     : 'right',\n  enumerable: true,\n  writable  : false,\n})\n\nObject.defineProperty(EitherLeft.prototype, 'isomer', {\n  value     : 'left',\n  enumerable: true,\n  writable  : false,\n})\n\n/**\n * Create right-handed value.\n *\n * Left-handed type is inferred from usage\n *\n * @template R\n * @template L\n * @param {R} value\n * @returns {Either<L, R>}\n */\nexport function Right<+L, R>(value: R): Either<L, R> {\n  return new EitherRight(value)\n}\n\n/**\n * Create left-handed value.\n *\n * Right-handed type is inferred from usage\n *\n * @template R\n * @template L\n * @param {L} value\n * @returns {Either<L, R>}\n */\nexport function Left<L, +R>(value: L): Either<L, R> {\n  return new EitherLeft(value)\n}\n\n/**\n * Create pure right-handed value\n *\n * Left-handed type is empty\n *\n * @template R\n * @param {R} value\n * @returns {Either<void, R>}\n */\nexport function of<R>(value: R): Either<void, R> {\n  return new EitherRight(value)\n}\n\n/**\n * Create pure left-handed value\n *\n * Right-handed type is empty\n *\n * @template L\n * @param {L} value\n * @returns {Either<L, void>}\n */\nexport function ofL<L>(value: L): Either<L, void> {\n  return new EitherLeft(value)\n}\n\n\n/**\n * Checks whether an object is an instance of `Either`\n *\n * @param {*} value\n * @returns {boolean}\n */\nexport function is(value: mixed): boolean %checks {\n  return value instanceof Isomer\n}\n\ndeclare function changeL<-L, +L1, R>(r: Either<L, R>): Either<L1, R>\n\ndeclare function concatL<L, +L1, R>(r: Either<L, R>): Either<L | L1, R>\n\ndeclare function changeR<L, -R, +R1>(r: Either<L, R>): Either<L, R1>\n\ndeclare function concatR<L, R, +R1>(r: Either<L, R>): Either<L, R | R1>\n"]}