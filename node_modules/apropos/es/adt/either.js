import '../index.h';
import Base from '../base';
import { failSafeStringify, addInterop } from '../util';

class Isomer extends Base {}

class EitherRight extends Isomer {
  constructor(value) {
    super();
    this.value = value;
    /*:: return this */
  }
  isRight() {
    return true;
  }
  isLeft() {
    return false;
  }

  orElse() {
    return this.value;
  }

  promise() {
    return Promise.resolve(this.value);
  }

  fold(l, r) {
    return r(this.value);
  }

  swap() {
    return new EitherLeft(this.value);
  }

  equals(value) {
    if (value instanceof Isomer) {
      if (value instanceof EitherRight) {
        return value.value === this.value;
      } else return false;
    } else return value === this.value;
  }

  // --- Tap section ---

  tap(fn) {
    return this.tapR(fn);
  }
  tapR(fn) {
    fn(this.value);
    return this;
  }
  tapL() {
    return this;
  }
  bitap(l, r) {
    return this.tapR(r);
  }

  // --- Map section ---

  map(fn) {
    return this.mapR(fn);
  }
  mapR(fn) {
    return new EitherRight(fn(this.value));
  }
  mapL() {
    return (/*:: changeL( */this
    ); /*::) */
  }
  bimap(l, r) {
    return (/*:: changeL( */this.mapR(r)
    ); /*::) */
  }

  // --- Chain section ---

  chain(fn) {
    return this.chainR(fn);
  }
  chainR(fn) {
    return (/*:: concatL(*/fn(this.value)
    ); /*::) */
  }
  chainL() {
    return (/*:: changeL(concatR(*/this
    ); /*::)) */
  }
  bichain(l, r) {
    return (/*:: concatR(concatL(*/r(this.value)
    ); /*::)) */
  }

  // --- Cond section ---

  cond(fn) {
    return fn(this.value);
  }

  chainCond(cond, pass, fail) {
    if (this.cond(cond)) return (/*:: concatL( */this.mapR(pass)
    ); /*::) */
    else return (/*:: changeR( */new EitherLeft(fail(this.value))
      ); /*::) */
  }

  logic(transformer) {
    var { cond, pass, fail } = transformer;
    return this.chainCond(cond, pass, fail);
  }

  // --- Combine section ---

  alt() {
    return (/*:: concatR(changeL( */this
    ); /*::)) */
  }

  or() {
    return (/*:: concatR(changeL( */this
    ); /*::)) */
  }

  and(e) {
    return (/*:: concatL(*/e
    ); /*::) */
  }

  thru(fn) {
    return fn(this);
  }

  ap(e) {
    if (e.isRight()) return (/*:: concatL(*/e /*::) */.mapR(fn => fn(this.value))
    );
    return (/*:: changeR(concatL( */e
    ); /*::)) */
  }

  toString() {
    return 'Right( ' + failSafeStringify(this.value) + ' )';
  }
}

class EitherLeft extends Isomer {
  constructor(value) {
    super();
    this.value = value;
    /*:: return this */
  }
  isRight() {
    return false;
  }
  isLeft() {
    return true;
  }

  orElse(value) {
    return value;
  }

  promise() {
    return Promise.reject(this.value);
  }

  fold(l /*::, r: (x: R) => O*/) {
    return l(this.value);
  }

  swap() {
    return new EitherRight(this.value);
  }

  equals(value) {
    if (value instanceof Isomer) {
      if (value instanceof EitherLeft) {
        return value.value === this.value;
      } else return false;
    } else return value === this.value;
  }

  // --- Tap section ---

  tap(fn) {
    return this.tapR(fn);
  }
  tapR() {
    return this;
  }
  tapL(fn) {
    fn(this.value);
    return this;
  }
  bitap(l) {
    return this.tapL(l);
  }

  // --- Map section ---

  map() {
    return (/*:: changeR( */this
    ); /*::) */
  }
  mapR() {
    return (/*:: changeR( */this
    ); /*::) */
  }
  mapL(fn) {
    return new EitherLeft(fn(this.value));
  }
  bimap(l /*::, r: (x: R) => R1*/) {
    return (/*:: changeR( */this.mapL(l)
    ); /*::) */
  }

  // --- Chain section ---

  chain(fn) {
    return this.chainR(fn);
  }
  chainR() {
    return (/*:: changeR(concatL(*/this
    ); /*::)) */
  }
  chainL(fn) {
    return (/*:: concatR(*/fn(this.value)
    ); /*::) */
  }
  bichain(l
  /*::, r: (x: R) => Either<L1, R1>*/
  ) {
    return (/*:: concatR(concatL(*/l(this.value)
    ); /*::)) */
  }

  // --- Cond section ---

  cond() {
    return false;
  }

  chainCond() {
    return (/*:: changeR(concatL(*/this
    ); /*::)) */
  }

  logic() {
    return (/*:: changeR(concatL(*/this
    ); /*::)) */
  }

  // --- Combine section ---

  alt(e) {
    return (/*:: concatR(*/e
    ); /*::) */
  }

  or(e) {
    return this.alt(e);
  }

  and() {
    return (/*:: changeR(concatL( */this
    ); /*::)) */
  }

  thru(fn) {
    return fn(this);
  }

  ap() {
    return (/*:: changeR(concatL( */this
    ); /*::)) */
  }

  toString() {
    return 'Left( ' + failSafeStringify(this.value) + ' )';
  }
}
addInterop(EitherRight, 'Either');
addInterop(EitherLeft, 'Either');
Object.defineProperty(EitherRight.prototype, 'isomer', {
  value: 'right',
  enumerable: true,
  writable: false
});

Object.defineProperty(EitherLeft.prototype, 'isomer', {
  value: 'left',
  enumerable: true,
  writable: false
});

/**
 * Create right-handed value.
 *
 * Left-handed type is inferred from usage
 *
 * @template R
 * @template L
 * @param {R} value
 * @returns {Either<L, R>}
 */
export function Right(value) {
  return new EitherRight(value);
}

/**
 * Create left-handed value.
 *
 * Right-handed type is inferred from usage
 *
 * @template R
 * @template L
 * @param {L} value
 * @returns {Either<L, R>}
 */
export function Left(value) {
  return new EitherLeft(value);
}

/**
 * Create pure right-handed value
 *
 * Left-handed type is empty
 *
 * @template R
 * @param {R} value
 * @returns {Either<void, R>}
 */
export function of(value) {
  return new EitherRight(value);
}

/**
 * Create pure left-handed value
 *
 * Right-handed type is empty
 *
 * @template L
 * @param {L} value
 * @returns {Either<L, void>}
 */
export function ofL(value) {
  return new EitherLeft(value);
}

/**
 * Checks whether an object is an instance of `Either`
 *
 * @param {*} value
 * @returns {boolean}
 */
export function is(value) {
  return value instanceof Isomer;
}
//# sourceMappingURL=either.js.map