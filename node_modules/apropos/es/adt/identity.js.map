{"version":3,"sources":["../../src/adt/identity.js"],"names":["Base","failSafeStringify","addInterop","Identityʹ","constructor","value","ap","id","chain","fn","map","f","get","equals","fold","toString","additionalProps","length","Object","defineProperties","prototype","empty","is","of"],"mappings":";;AAEA;;AAEA,OAA8B,YAA9B;AACA,OAAOA,IAAP,MAAiB,SAAjB;AACA,SAASC,iBAAT,EAA4BC,UAA5B,QAA8C,SAA9C;;AAIA,MAAMC,SAAN,SAA2BH,IAA3B,CAAuD;AAGrDI,cAAYC,KAAZ,EAAmC;AACjC;AACA;AACA;AACA;AACA,SAAKA,KAAL,GAAaA,KAAb;AACA;AACD;AACDC,KAAMC,EAAN,EAAgD;AAC9C,WAAOA,GAAGC,KAAH,CAASC,MAAM,IAAIN,SAAJ,CAAcM,GAAG,KAAKJ,KAAR,CAAd,CAAf,CAAP;AACD;AACDK,MAAOC,CAAP,EAAoC;AAClC,WAAO,IAAIR,SAAJ,CAAcQ,EAAE,KAAKN,KAAP,CAAd,CAAP;AACD;AACDG,QAASC,EAAT,EAAiD;AAC/C,WAAOA,GAAG,KAAKJ,KAAR,CAAP;AACD;AACDO,QAAS;AACP,WAAO,KAAKP,KAAZ;AACD;AACDQ,SAAOR,KAAP,EAA4B;AAC1B,QAAIA,iBAAiBF,SAArB,EACE,OAAO,KAAKE,KAAL,KAAeA,MAAMA,KAA5B;AACF,WAAO,KAAKA,KAAL,KAAeA,KAAtB;AACD;;AAEDS,OAAQL,EAAR,EAA4B;AAC1B,WAAOA,GAAG,KAAKJ,KAAR,CAAP;AACD;;AAEDU,aAAW;AACT,WAAQ,YAAad,kBAAkB,KAAKI,KAAvB,CAAgC,GAArD;AACD;AAnCoD;;AAsCvDH,WAAWC,SAAX,EAAsB,UAAtB;;AAEA,IAAMa,kBAAkB;AACtBC,UAAQ;AACNZ,WAAO;AADD;AADc,CAAxB;;AAMAW,gBAAgB,6BAAhB,CAA+C,CAA/C,IAAoD;AAClDJ,QAAM;AACJ,WAAO,KAAKP,KAAZ;AACD;AAHiD,CAApD;;AAMAa,OAAOC,gBAAP,CAAwBhB,UAAUiB,SAAlC,EAA6CJ,eAA7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASK,KAAT,GAAiC;AACtC,SAAO,IAAIlB,SAAJ,CAAc,KAAK,CAAnB,CAAP;AACD;;AAED,OAAO,SAASmB,EAAT,CAAYjB,KAAZ,EAAiC;AACtC,SAAOA,iBAAiBF,SAAxB;AACD;;AAED;;;;;;AAMA,OAAO,SAASoB,EAAT,CAAgBlB,KAAhB,EAAyC;AAC9C,SAAO,IAAIF,SAAJ,CAAcE,KAAd,CAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"identity.js","sourcesContent":["//@flow\n\n/* eslint-disable no-whitespace-before-property */\n\nimport { type Identity } from '../index.h'\nimport Base from '../base'\nimport { failSafeStringify, addInterop } from '../util'\n\nexport type { Identity }\n\nclass Identityʹ<T> extends Base implements Identity<T> {\n  value: T\n  length: number\n  constructor(value: T): Identity<T> {\n    super()\n    // if (value instanceof ChainRecNext || value instanceof ChainRecDone)\n    //   this.value = value.value\n    // else\n    this.value = value\n    /*:: return this */\n  }\n  ap<S>(id: Identity<((x: T) => S)>): Identity<S> {\n    return id.chain(fn => new Identityʹ(fn(this.value)))\n  }\n  map<O>(f: (x: T) => O): Identity<O> {\n    return new Identityʹ(f(this.value))\n  }\n  chain<O>(fn: (x: T) => Identity<O>): Identity<O> {\n    return fn(this.value)\n  }\n  get(): T {\n    return this.value\n  }\n  equals(value: any): boolean {\n    if (value instanceof Identityʹ)\n      return this.value === value.value\n    return this.value === value\n  }\n\n  fold<O>(fn: (x: T) => O): O {\n    return fn(this.value)\n  }\n\n  toString() {\n    return `Identity(${  failSafeStringify(this.value)  })`\n  }\n}\n\naddInterop(Identityʹ, 'Identity')\n\nconst additionalProps = {\n  length: {\n    value: 1\n  },\n}\n\nadditionalProps /*:: ; const noa = {}; noa */ [0] = {\n  get() {\n    return this.value\n  }\n}\n\nObject.defineProperties(Identityʹ.prototype, additionalProps)\n\n// import { toString, equals } from 'ramda'\n//\n// import {\n//   ᐸMapᐳ,\n//   ᐸChainᐳ,\n//   ᐸEmptyᐳ,\n//   ᐸChainRecᐳ,\n//   ᐸOfᐳ,\n//   λMap,\n//   λChain,\n// } from './index.h'\n//\n// export type ChainRec<T> = {\n//   isNext: boolean,\n//   value: T,\n// }\n//\n// export type CanBeMapped<V> = {\n//   map<T>(fn: (x: V) => T): CanBeMapped<T>,\n// }\n//\n// type ChainRecF = <T>(x: T) => ChainRec<T>\n//\n// type ChainRecIterator = <-I, O>(next: ChainRecF, done: ChainRecF, value: I) => ChainRec<O>\n//\n// class ChainRecNext<T> {\n//   isNext: boolean = true\n//   done: boolean = false\n//   value: T\n//   constructor(value: T): ChainRec<T> {\n//     this.value = value\n//     /*:: return this */\n//   }\n//   static of<Tʹ>(value: Tʹ): ChainRec<Tʹ> {\n//     return new ChainRecNext(value)\n//   }\n// }\n//\n// class ChainRecDone<T> {\n//   isNext: boolean = false\n//   done: boolean = true\n//   value: T\n//   constructor(value: T): ChainRec<T> {\n//     this.value = value\n//     /*:: return this */\n//   }\n//   static of<Tʹ>(value: Tʹ): ChainRec<Tʹ> {\n//     return new ChainRecDone(value)\n//   }\n// }\n//\n// /**\n//  * A data type that holds a value and exposes a monadic api.\n//  */\n// export\n// class Identity<T>\n// implements\n//   λMap<'Identity', T>,\n//   λChain<'Identity', T>\n// {\n//   typeName: 'Identity'\n//   value: T\n//   /**\n//    * Constructs a new `Identity[a]` data type that holds a single\n//    * value `a`.\n//    * @param {*} a Value of any type\n//    * @sig a -> Identity[a]\n//    */\n//   constructor(value: T) {\n//     if (value instanceof ChainRecNext || value instanceof ChainRecDone)\n//       this.value = value.value\n//     else\n//       this.value = value\n//   }\n//\n//   /**\n//    * Functor specification. Creates a new `Identity[a]` mapping function `f` onto\n//    * `a` returning any value b.\n//    * @param {Function} f Maps `a` to any value `b`\n//    * @returns Identity[b]\n//    * @sig @Identity[a] => (a -> b) -> Identity[b]\n//    */\n//   map<O>(f: (x: T) => O): Identity<O> {\n//     return new Identity(f(this.value))\n//   }\n//\n//   /**\n//    * Chain specification. Transforms the value of the `Identity[a]`\n//    * type using an unary function to monads. The `Identity[a]` type\n//    * should contain a function, otherwise an error is thrown.\n//    *\n//    * @param {Function} fn Transforms `a` into a `Monad[b]`\n//    * @returns Monad[b]\n//    * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]\n//    */\n//   chain<Name, O>(fn: (x: T) => λChain<Name, O>): λChain<Name, O> {\n//     return fn(this.value)\n//   }\n//\n//   /**\n//    * Returns the value of `Identity[a]`\n//    *\n//    * @returns a\n//    * @sig (Identity[a]) => a\n//    */\n//   get(): T {\n//     return this.value\n//   }\n//\n//   equals(value: any): boolean {\n//     if (value instanceof Identity)\n//       return equals(this.value, value.value)\n//     return equals(this.value, value)\n//   }\n//\n//   toString() {\n//     return `Identity(${  toString(this.value)  })`\n//   }\n//\n//   static is = is\n//\n//   static of = of\n//\n//   static empty = empty\n//\n//   // static ap = ap\n//\n//   static chainRec = chainRec\n// }\n//\n// const typeID = 'zero-bias/Identity@1'\n//\n// export const MIdentity: (\n//   & ᐸMapᐳ<'Identity'>\n//   & ᐸOfᐳ<'Identity'>\n//   & ᐸEmptyᐳ<'Identity'>\n//   & ᐸChainᐳ<'Identity'>\n//   & ᐸChainRecᐳ<'Identity'>\n// ) = {\n//   '@@type'               : typeID,\n//   chainRec,\n//   'fantasy-land/chainRec': chainRec,\n//   of                     : <T>(value: T): Identity<T> => new Identity(value),\n//   'fantasy-land/of'      : <T>(value: T): Identity<T> => new Identity(value),\n//   empty                  : (): Identity<void> => new Identity(void 0),\n//   'fantasy-land/empty'   : (): Identity<void> => new Identity(void 0),\n// }\n\nexport function empty(): Identity<void> {\n  return new Identityʹ(void 0)\n}\n\nexport function is(value: any): boolean {\n  return value instanceof Identityʹ\n}\n\n/**\n * Applicative specification. Creates a new `Identity[a]` holding the value `a`.\n * @param {*} a Value of any type\n * @returns Identity[a]\n * @sig a -> Identity[a]\n */\nexport function of<Tʹ>(value: Tʹ): Identity<Tʹ> {\n  return new Identityʹ(value)\n}\n\n// export function chainRec<Tʹ, N>(f: ChainRecIterator, i: Tʹ): Identity<N> {\n//   let state = new ChainRecNext(i)\n//   while (state.isNext) {\n//     state = f(ChainRecNext.of, ChainRecDone.of, state.value)\n//   }\n//   declare var n: N\n//   return new Identity((state.value /*:: , n */ ))\n// }\n\n// /**\n//  * Apply specification. Applies the function inside the `Identity[a]`\n//  * type to another applicative type.\n//  * @param {Applicative[a]} app Applicative that will apply its function\n//  * @returns Applicative[b]\n//  * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]\n//  */\n\n// export function ap<I, O>(mapper: Identity<((x: I) => O)>, value: CanBeMapped<I>): CanBeMapped<O> {\n//   return value.map(mapper.value)\n// }\n//\n//\n// /*::  ; const dull = {} */\n//\n// Object.assign(/*:: dull, */ Identity, MIdentity)\n\n// //eslint-disable-next-line\n// Identity.prototype /*:: ; dull */ .ap =\n//   function(value: any) {\n//     return Identity.ap(this, value)\n//   }\n"]}